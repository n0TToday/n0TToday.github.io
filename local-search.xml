<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HEXO 博客基础搭建</title>
    <link href="/2022/01/24/HEXO%20%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%85%A8%E7%BA%AA%E5%BD%95/"/>
    <url>/2022/01/24/HEXO%20%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%85%A8%E7%BA%AA%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO-博客基础搭建"><a href="#HEXO-博客基础搭建" class="headerlink" title="HEXO 博客基础搭建"></a>HEXO 博客基础搭建</h1><p>许久未见，博客迁移至 hexo 平台，记录这一过程作为新博客的第一篇文章。</p><span id="more"></span><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><ul><li>Node.js &amp; NPM</li><li>Python</li><li>Git</li><li>Github Page</li><li>Hexo</li></ul><h3 id="1-1-Node-js-安装"><a href="#1-1-Node-js-安装" class="headerlink" title="1.1 Node.js 安装"></a>1.1 Node.js 安装</h3><ul><li>安装 <a href="https://github.com/coreybutler/nvm-windows/releases">nvm</a> </li><li>使用 nvm 安装 LTS 版本的 Node.js</li><li><code>nvm use lts</code></li></ul><h3 id="1-2-NPM-配置"><a href="#1-2-NPM-配置" class="headerlink" title="1.2 NPM 配置"></a>1.2 NPM 配置</h3><ul><li><p><code>npm config set proxy http://127.0.0.1:7890</code> 走 Clash 代理</p></li><li><p><code>npm config set registry https://registry.npm.taobao.org</code> 将镜像源改为淘宝</p></li></ul><h3 id="1-3-Python、Git-安装"><a href="#1-3-Python、Git-安装" class="headerlink" title="1.3 Python、Git 安装"></a>1.3 Python、Git 安装</h3><ul><li>官网下载安装包安装即可，已安装</li></ul><h3 id="1-4-Git-基本配置"><a href="#1-4-Git-基本配置" class="headerlink" title="1.4 Git 基本配置"></a>1.4 Git 基本配置</h3><ul><li><code>git config --global user.name &quot;username&quot;</code></li><li><code>git config --global user.email &quot;user@email.com&quot;</code></li></ul><h2 id="2-HEXO-配置"><a href="#2-HEXO-配置" class="headerlink" title="2. HEXO 配置"></a>2. HEXO 配置</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p><code>npm install -g hexo-cli</code></p><h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm i<br></code></pre></td></tr></table></figure><h3 id="2-3-配置部署"><a href="#2-3-配置部署" class="headerlink" title="2.3 配置部署"></a>2.3 配置部署</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;username&gt;/&lt;project&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-1-Git-本地-SSH-配置"><a href="#2-3-1-Git-本地-SSH-配置" class="headerlink" title="2.3.1 Git 本地 SSH 配置"></a>2.3.1 Git 本地 SSH 配置</h4><p>详见<a href="https://www.cnblogs.com/yinminbo/p/11810302.html">这篇文章</a></p><h4 id="2-3-2-安装-hexo-git-插件"><a href="#2-3-2-安装-hexo-git-插件" class="headerlink" title="2.3.2 安装 hexo-git 插件"></a>2.3.2 安装 hexo-git 插件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm install hexo<span class="hljs-literal">-deployer</span><span class="hljs-literal">-git</span> -<span class="hljs-literal">-save</span><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-4-HEXO-主题安装"><a href="#2-4-HEXO-主题安装" class="headerlink" title="2.4 HEXO 主题安装"></a>2.4 HEXO 主题安装</h3><p>自用主题 -&gt; <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm install -<span class="hljs-literal">-save</span> hexo<span class="hljs-literal">-theme</span><span class="hljs-literal">-fluid</span><br></code></pre></td></tr></table></figure><h3 id="2-5-本地服务器测试"><a href="#2-5-本地服务器测试" class="headerlink" title="2.5 本地服务器测试"></a>2.5 本地服务器测试</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm install hexo<span class="hljs-literal">-server</span> -<span class="hljs-literal">-save</span><br><span class="hljs-variable">$</span> hexo server<br></code></pre></td></tr></table></figure><h3 id="2-6-新建、生成与发布"><a href="#2-6-新建、生成与发布" class="headerlink" title="2.6 新建、生成与发布"></a>2.6 新建、生成与发布</h3><ul><li><code> hexo new &quot;post title&quot;</code></li><li><code>hexo g -f</code></li><li><code>hexo d -g</code></li></ul><h2 id="3-运行效果"><a href="#3-运行效果" class="headerlink" title="3. 运行效果"></a>3. 运行效果</h2><p><img src="http://cdn.n0t.top/img/image-20220125135841851.png" alt="blog.n0t.top"></p>]]></content>
    
    
    <categories>
      
      <category>HEXO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>Blog</tag>
      
      <tag>GEEK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS:GO - 服务器公告</title>
    <link href="/2020/05/28/CS-GO---%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%AC%E5%91%8A/"/>
    <url>/2020/05/28/CS-GO---%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%AC%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="CSGO-服务器公告"><a href="#CSGO-服务器公告" class="headerlink" title="[CSGO] 服务器公告"></a>[CSGO] 服务器公告</h1><blockquote><p>Tick：128<br>模式：死斗<br>用途：练枪、测试皮肤<br>By n0T</p></blockquote><span id="more"></span><h2 id="1-服务器连接方式"><a href="#1-服务器连接方式" class="headerlink" title="1. 服务器连接方式"></a>1. 服务器连接方式</h2><p>进入 CSGO，控制台输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">connect n0t.top;password zxcvbnm.<br></code></pre></td></tr></table></figure><h2 id="2-皮肤修改（仅供测试）"><a href="#2-皮肤修改（仅供测试）" class="headerlink" title="2. 皮肤修改（仅供测试）"></a>2. 皮肤修改（仅供测试）</h2><p><em>社区服务器中的皮肤修改 <strong>不会影响</strong> VAC。</em></p><p>在聊天框中输入：</p><ul><li><p><code>!ws</code></p><ul><li>武器及刀 的皮肤</li><li>磨损（默认无磨损，修改以 %5 递进）</li><li>计数器（开启/关闭）</li><li>名称标签</li><li>模板编号（全蓝淬火不是梦）</li></ul></li><li><p><code>!knife</code></p><ul><li>更改 刀</li></ul></li><li><p><code>!glove</code></p><ul><li>单独修改手套</li><li>磨损</li></ul></li></ul><p>皮肤修改后自动保存至服务器，下次登录自动加载。</p><p><img src="http://img4.18183.duoku.com/uploads/allimg/160905/60-160Z5164634.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSGO</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 笔记 - 6. 树</title>
    <link href="/2020/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---6.-%E6%A0%91/"/>
    <url>/2020/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---6.-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="6-树（Tree）"><a href="#6-树（Tree）" class="headerlink" title="6. 树（Tree）"></a>6. 树（Tree）</h1><h2 id="6-1-树的定义"><a href="#6-1-树的定义" class="headerlink" title="6.1 树的定义"></a>6.1 树的定义</h2><span id="more"></span><ul><li><p>是 n(n&gt;=0) 个结点的有限集。当 n=0 时成为空树，在任意一颗非空树中：</p><ul><li>有且仅有一个特定的称为根（ROOT）的结点</li><li>当 n&gt;1 时，其余结点可分为 m(m&gt;0) 个互不相交的有限集 T1、T2、…、Tm，其中每一个集合本身又是一棵树，并成为根的子树（SubTree）</li></ul></li><li><p>每一个结点拥有的子树称为结点的度（Degree），树的度取树内各结点的度的最大值</p><ul><li>度为 0 的结点称为叶结点（Leaf）或终端结点</li><li>度不为 0 的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点</li></ul></li><li><p>结点之间的关系</p><ul><li>结点的子树的根称为结点的 Child，相应的，该结点称为 Child 的 Parent，同一 Parent 的 Child 之间互称为 Sibling</li><li>结点的祖先是从根到该结点所经分支上的所有结点</li></ul></li><li><p>结点的层次</p><ul><li>从根开始，根为第一层，依次顺延</li><li>其双亲在同一层的结点互为堂兄弟</li><li>树中结点的最大层次称为树的深度或高度</li></ul></li><li><p>其他概念</p><ul><li>如果树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，反之为无序树</li><li>森林是 m(m&gt;=0) 棵互不相交的树的集合。对于树中每个结点而言，其子树的集合即为森林</li></ul></li></ul><h2 id="6-2-树的存储结构"><a href="#6-2-树的存储结构" class="headerlink" title="6.2 树的存储结构"></a>6.2 树的存储结构</h2><h3 id="6-2-1-双亲表示法"><a href="#6-2-1-双亲表示法" class="headerlink" title="6.2.1 双亲表示法"></a>6.2.1 双亲表示法</h3><p>以双亲作为索引的关键词的一种存储方式。</p><p>假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示其双亲结点在数组中位置的元素。</p><ul><li><p>结构定义</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTNode</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">// 结点位置</span><br>  ElemType data;<br>  <span class="hljs-comment">// 双亲位置</span><br>  <span class="hljs-keyword">int</span> parent;<br>&#125; PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  PTNode nodes[MAX_TREE_SIZE];<br>  <span class="hljs-comment">// 根的位置</span><br>  <span class="hljs-keyword">int</span> r;<br>  <span class="hljs-comment">// 结点数目</span><br>  <span class="hljs-keyword">int</span> n;<br>&#125;PTree;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-2-2-双亲孩子表示法"><a href="#6-2-2-双亲孩子表示法" class="headerlink" title="6.2.2 双亲孩子表示法"></a>6.2.2 双亲孩子表示法</h3><ul><li><p>结构定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">int</span> child;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; * ChildPtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType data;<br>  <span class="hljs-keyword">int</span> parent;<br>  ChildPtr firstChild;<br>&#125; CTBox;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  CTBox nodes[MAXSIZE];<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-3-二叉树"><a href="#6-3-二叉树" class="headerlink" title="6.3 二叉树"></a>6.3 二叉树</h2><h3 id="6-3-1-定义"><a href="#6-3-1-定义" class="headerlink" title="6.3.1 定义"></a>6.3.1 定义</h3><ul><li><p>是 n(n&gt;=0) 个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根节点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成</p></li><li><p>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点</p></li><li><p>即使树中某结点只有一颗子树，也要区分他是左子树还是右子树</p></li></ul><h3 id="6-3-2-五种基本形态"><a href="#6-3-2-五种基本形态" class="headerlink" title="6.3.2 五种基本形态"></a>6.3.2 五种基本形态</h3><ul><li><p>空二叉树</p></li><li><p>只有一个根节点</p></li><li><p>根节点只有左子树</p></li><li><p>根节点只有右子树</p></li><li><p>根结点既有左子树又有右子树</p></li></ul><h3 id="6-3-3-特殊二叉树"><a href="#6-3-3-特殊二叉树" class="headerlink" title="6.3.3 特殊二叉树"></a>6.3.3 特殊二叉树</h3><ul><li><p>斜树</p></li><li><p><strong>满二叉树</strong></p></li><li><p><strong>完全二叉树</strong></p></li></ul><h3 id="6-3-4-性质"><a href="#6-3-4-性质" class="headerlink" title="6.3.4 性质"></a>6.3.4 性质</h3><ol><li>在二叉树的第 i 层上至多有 <code>2^(i-1)</code> 个结点(i&gt;=1)</li><li>深度为 k 的二叉树至多有 <code>2^k -1</code> 个结点</li><li>对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则 <code>n0=n2+1</code></li><li>具有 n 个结点的完全二叉树的深度为 <code>Log2n取下限 +1</code></li><li>对于一棵有 n 个结点的完全二叉树的结点按层序编号，则对任意结点 i(1&lt;=i&lt;=n)，有：<ol><li>如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i&gt;1，则其双亲 PARENT(i) 是结点 <code>i/2取下限</code></li><li>如果 2i&gt;n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子 LCHILD(i) 是结点 2i</li><li>如果 2i+1&gt;n，则结点 i 无右孩子；否则其右孩子 RCHILD(i) 是结点 2i+1</li></ol></li></ol><h3 id="6-3-5-二叉树的存储结构"><a href="#6-3-5-二叉树的存储结构" class="headerlink" title="6.3.5 二叉树的存储结构"></a>6.3.5 二叉树的存储结构</h3><ul><li><p>顺序存储结构</p><ul><li>一维数组实现</li><li>斜树等结构浪费空间 实用性不强</li></ul></li><li><p>链式存储结构</p><ul><li><p><strong>二叉链表</strong></p><ul><li>一个数据域</li><li>两个指针域</li></ul></li><li><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125; BiTNode, *BiTree;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-3-6-二叉树的遍历"><a href="#6-3-6-二叉树的遍历" class="headerlink" title="6.3.6 二叉树的遍历"></a>6.3.6 二叉树的遍历</h3><ul><li><p>从根节点出发，按照某种<strong>次序</strong>依次<strong>访问</strong>二叉树中所有结点，使得每个节点被访问一次且<strong>仅被访问一次</strong></p></li><li><p>前序遍历</p><ul><li>若二叉树为空，则空操作返回；若不为空， 先访问根结点，然后前序遍历左子树，再前序遍历右子树</li></ul></li><li><p>中序遍历</p><ul><li>若树为空，则空操作返回；若不为空，从根节点开始，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树</li></ul></li><li><p>后序遍历</p><ul><li>若树为空，则空操作返回；若不为空，从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点</li></ul></li><li><p>层序遍历</p><ul><li>若树为空，则空操作返回；若不为空，从树的第一层，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</li></ul></li><li><p>遍历代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;malloc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125; BiTNode, *BiTree;<br><br><span class="hljs-comment">// 创建一棵二叉树，约定用户遵照前序遍历的方式输入数据</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> c;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27; &#x27;</span> == c)<br>  &#123;<br>    *T = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *T = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<br>    (*T)-&gt;data = c;<br>    CreateBiTree(&amp;(*T)-&gt;lchild);<br>    CreateBiTree(&amp;(*T)-&gt;rchild);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 访问二叉树结点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ElemType c, <span class="hljs-keyword">int</span> level)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c在第%d层\n&quot;</span>, c, level);<br>&#125;<br><br><span class="hljs-comment">// 遍历二叉树</span><br><br><span class="hljs-comment">// 1. 前序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T, <span class="hljs-keyword">int</span> level)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (T)<br>  &#123;<br>    visit(T-&gt;data, level);<br>    PreOrderTraverse(T-&gt;lchild, level + <span class="hljs-number">1</span>);<br>    PreOrderTraverse(T-&gt;rchild, level + <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 2. 中序遍历</span><br><br><span class="hljs-comment">// 3. 后序遍历</span><br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>  BiTree T = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入二叉树:&quot;</span>);<br>  CreateBiTree(&amp;T);<br>  PreOrderTraverse(T, level);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-3-7-线索二叉树"><a href="#6-3-7-线索二叉树" class="headerlink" title="6.3.7 线索二叉树"></a>6.3.7 线索二叉树</h3><h3 id="6-3-8-树、森林、二叉树的转换"><a href="#6-3-8-树、森林、二叉树的转换" class="headerlink" title="6.3.8 树、森林、二叉树的转换"></a>6.3.8 树、森林、二叉树的转换</h3><p>左孩子右兄弟</p><h2 id="6-4-哈夫曼树"><a href="#6-4-哈夫曼树" class="headerlink" title="6.4 哈夫曼树"></a>6.4 哈夫曼树</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 笔记 - 5. 串及 KMP 算法</title>
    <link href="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---5.-%E4%B8%B2%E5%8F%8A-KMP-%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---5.-%E4%B8%B2%E5%8F%8A-KMP-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="5-串"><a href="#5-串" class="headerlink" title="5. 串"></a>5. 串</h1><h2 id="5-1-串的定义"><a href="#5-1-串的定义" class="headerlink" title="5.1 串的定义"></a>5.1 串的定义</h2><span id="more"></span><ul><li><p>定义</p><ul><li>串（String）是由零个或多个字符组成的<strong>有限</strong>序列，又叫字符串。</li><li>串可以是空串，直接由“”表示，或用希腊字母 <code>φ</code> 来表示。</li></ul></li><li><p>子串与主串</p><ul><li><code>end</code> 是 <code>friend</code> 的子串</li><li><code>asdfg</code> 是 <code>qwerasdfgzxcv</code> 的子串</li></ul></li></ul><h2 id="5-2-字符串的比较"><a href="#5-2-字符串的比较" class="headerlink" title="5.2 字符串的比较"></a>5.2 字符串的比较</h2><ul><li><p>比大小</p><ul><li>对比字符串中 ASCII码 的大小</li></ul></li><li><p>比相等</p></li></ul><h2 id="5-3-字符串的存储结构"><a href="#5-3-字符串的存储结构" class="headerlink" title="5.3 字符串的存储结构"></a>5.3 字符串的存储结构</h2><h3 id="5-3-1-顺序存储结构"><a href="#5-3-1-顺序存储结构" class="headerlink" title="5.3.1 顺序存储结构"></a>5.3.1 顺序存储结构</h3><ul><li>顺序存储结构使用一组地址连续的存储单元来存储串中字符序列</li><li>按照预定义的大小，为每个定义的字符串变量分配一个固定长度的存储区，一般用定长数组来定义。</li></ul><h2 id="5-4-BF算法（Brute-Force）"><a href="#5-4-BF算法（Brute-Force）" class="headerlink" title="5.4 BF算法（Brute Force）"></a>5.4 BF算法（Brute Force）</h2><h2 id="5-5-KMP算法"><a href="#5-5-KMP算法" class="headerlink" title="5.5 KMP算法"></a>5.5 KMP算法</h2><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(String T, <span class="hljs-keyword">int</span> next)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == j || T[i] == T[j])<br>  &#123;<br>    i++;<br>    j++;<br>    next[i] = j;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    j = next[j];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 返回子串 T 在主串 S 第 pos 个字符之后的位置</span><br><span class="hljs-comment">// 若不存在，则返回 0</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(String S, String T, <span class="hljs-keyword">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i = pos;<br>  <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> next[<span class="hljs-number">255</span>];<br><br>  get_next(T, next);<br><br>  <span class="hljs-keyword">while</span> (i &lt;= S[<span class="hljs-number">0</span>] &amp;&amp; j &lt;= T[<span class="hljs-number">0</span>])<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == j || S[i] == T[j])<br>    &#123;<br>      i++;<br>      j++;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      next[i] = next[j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (j &gt; T[<span class="hljs-number">0</span>])<br>  &#123;<br>    <span class="hljs-keyword">return</span> i - T[<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 笔记 - 4. 递归</title>
    <link href="/2020/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---4.-%E9%80%92%E5%BD%92/"/>
    <url>/2020/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---4.-%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="4-递归"><a href="#4-递归" class="headerlink" title="4. 递归"></a>4. 递归</h1><h2 id="4-1-递归的定义"><a href="#4-1-递归的定义" class="headerlink" title="4.1 递归的定义"></a>4.1 递归的定义</h2><span id="more"></span><ul><li><p>在高级语言中，函数调用自己和调用其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接的调用自己的函数，称作递归函数。</p></li><li><p>每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回。</p></li><li><p>迭代和递归的区别：迭代使用的是循环结构，递归使用的是选择结构。</p><ul><li>使用递归能使程序的结构更清晰、更简洁、具有更高的可读性</li><li>但大量的递归调用会消耗大量的时间和内存，而迭代不需要此种付出。</li></ul></li><li><p>递归函数分为调用和回退阶段，递归的回退顺序是它调用顺序的逆序。</p></li></ul><h2 id="4-2-递归思想反向输出字符串"><a href="#4-2-递归思想反向输出字符串" class="headerlink" title="4.2 递归思想反向输出字符串"></a>4.2 递归思想反向输出字符串</h2><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> a;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, a);<br>  <span class="hljs-keyword">if</span> (a != <span class="hljs-string">&#x27;#&#x27;</span>)<br>  &#123;<br>    print();<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (a != <span class="hljs-string">&#x27;#&#x27;</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;#c&quot;</span>, a);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-汉诺塔问题-递归与分治"><a href="#4-3-汉诺塔问题-递归与分治" class="headerlink" title="4.3 汉诺塔问题 - 递归与分治"></a>4.3 汉诺塔问题 - 递归与分治</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> x, <span class="hljs-keyword">char</span> y, <span class="hljs-keyword">char</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == n)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c--&gt;%c\n&quot;</span>, x, z);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    move(n - <span class="hljs-number">1</span>, x, z, y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c-&gt;%c\n&quot;</span>, x, z);<br>    move(n - <span class="hljs-number">1</span>, y, x, z);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入汉诺塔的层数：&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;移动的步骤如下：\n&quot;</span>);<br>  move(n, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-八皇后问题"><a href="#4-4-八皇后问题" class="headerlink" title="4.4 八皇后问题"></a>4.4 八皇后问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">noDanger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> (*chess)[<span class="hljs-number">8</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, k;<br>  <span class="hljs-keyword">int</span> flag1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> flag2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> flag3 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> flag4 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> flag5 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 判断列方向危险</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (*(*(chess + i) + j) != <span class="hljs-number">0</span>)<br>    &#123;<br>      flag1 = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 判断左上方</span><br>  <span class="hljs-keyword">for</span> (i = row, k = j; i &gt;= <span class="hljs-number">0</span> &amp;&amp; k &gt;= <span class="hljs-number">0</span>; i--, k--)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (*(*(chess + i) + k) != <span class="hljs-number">0</span>)<br>    &#123;<br>      flag2 = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 判断右下方</span><br>  <span class="hljs-keyword">for</span> (i = row, k = j; i &lt; <span class="hljs-number">8</span> &amp;&amp; k &lt; <span class="hljs-number">8</span>; i++, k++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (*(*(chess + i) + k) != <span class="hljs-number">0</span>)<br>    &#123;<br>      flag3 = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 判断右上方</span><br>  <span class="hljs-keyword">for</span> (i = row, k = j; i &gt;= <span class="hljs-number">0</span> &amp;&amp; k &lt; <span class="hljs-number">8</span>; i--, k++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (*(*(chess + i) + k) != <span class="hljs-number">0</span>)<br>    &#123;<br>      flag4 = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 判断左下方</span><br>  <span class="hljs-keyword">for</span> (i = row, k = j; i &lt; <span class="hljs-number">8</span> &amp;&amp; k &gt;= <span class="hljs-number">0</span>; i++, k--)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (*(*(chess + i) + k) != <span class="hljs-number">0</span>)<br>    &#123;<br>      flag5 = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (flag1 || flag3 || flag2 || flag4 || flag5)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 参数 row 表示起始行</span><br><span class="hljs-comment">// 参数 n 表示列数</span><br><span class="hljs-comment">// 参数 (*chess)[8] 表示指向棋盘每一行的指针</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eQueen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> (*chess)[<span class="hljs-number">8</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 定义临时棋盘</span><br>  <span class="hljs-keyword">int</span> chess2[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>], i, j;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>    &#123;<br>      chess2[i][j] = chess[i][j];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 开始递归</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">8</span> == row)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第 %d 种\n&quot;</span>, count + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>      <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *(*(chess2 + i) + j));<br>      &#125;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    count++;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (noDanger(row, j, chess))<br>      &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        &#123;<br>          *(*(chess2 + row) + i) = <span class="hljs-number">0</span>;<br>        &#125;<br>        *(*(chess2 + row) + j) = <span class="hljs-number">1</span>;<br>        eQueen(row + <span class="hljs-number">1</span>, n, chess2);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 定义棋盘</span><br>  <span class="hljs-keyword">int</span> chess[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>], i, j;<br><br>  <span class="hljs-comment">// 初始化棋盘</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>    &#123;<br>      chess[i][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  eQueen(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, chess);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;总共有%d种解决方法\n&quot;</span>, count);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 笔记 - 3. 栈和队列</title>
    <link href="/2020/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---3.-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2020/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---3.-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3. 栈和队列"></a>3. 栈和队列</h1><h2 id="3-1-栈的定义"><a href="#3-1-栈的定义" class="headerlink" title="3.1 栈的定义"></a>3.1 栈的定义</h2><span id="more"></span><ul><li><p>栈（Stack）是一种重要的线性结构，可以说栈是前面讲过的线性表的具体形式。</p></li><li><p>栈是一个<strong>后进先出（Last in first out,LIFO）</strong>的线性表，<strong>只在表尾</strong>进行删除和插入操作。</p></li><li><p>对于栈来说，这个表尾称为栈的<strong>栈顶（top）</strong>，相应的表头称为<strong>栈底（bottom）</strong>。</p></li><li><p>栈的插入和删除操作</p><ul><li>栈的插入操作<strong>进栈（Push）</strong>，也称为压栈，入栈。类似子弹放入弹夹的动作。</li><li>栈的删除操作<strong>出栈（Pop）</strong>，也称为弹栈。</li></ul></li></ul><h2 id="3-2-栈的顺序存储结构"><a href="#3-2-栈的顺序存储结构" class="headerlink" title="3.2 栈的顺序存储结构"></a>3.2 栈的顺序存储结构</h2><h3 id="3-2-1-定义"><a href="#3-2-1-定义" class="headerlink" title="3.2.1 定义"></a>3.2.1 定义</h3><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType *base;<br>  ElemType *top;<br>  <span class="hljs-keyword">int</span> stackSize;<br>&#125;sqStack;<br></code></pre></td></tr></table></figure><ul><li>top：指向栈顶的指针变量</li><li>base：指向栈底的指针变量</li><li>stackSize：指栈当前可使用的最大容量</li></ul><h3 id="3-2-2-栈的基本操作的实现"><a href="#3-2-2-栈的基本操作的实现" class="headerlink" title="3.2.2 栈的基本操作的实现"></a>3.2.2 栈的基本操作的实现</h3><ul><li><p>初始化 <code>initStack</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK_INIT_SIZE 100</span><br>initStack(sqStack *s)<br>&#123;<br>  s-&gt;base = (ElemType *)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-keyword">sizeof</span>(ElemType));<br>  <span class="hljs-keyword">if</span> (!s-&gt;base)<br>  &#123;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  s-&gt;top = s-&gt;base;<br>  s-&gt;stackSize = STACK_INIT_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>入栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACKINCREMENT 10</span><br><br>Push(sqStack *s, ElemType e)<br>&#123;<br>  <span class="hljs-keyword">if</span> (s-&gt;top - s-&gt;base &gt;= s-&gt;stackSize)<br>  &#123;<br>    s-&gt;base = (ElemType *)<span class="hljs-built_in">realloc</span>(s-&gt;base, (s-&gt;stackSize + STACKINCREMENT) * <span class="hljs-keyword">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span> (!s-&gt;base)<br>    &#123;<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    s-&gt;top = s-&gt;base + s-&gt;stackSize;<br>    s-&gt;stackSize = s-&gt;stackSize + STACKINCREMENT;<br>  &#125;<br>  *(s-&gt;top) = e;<br>  s-&gt;top++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>出栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">(sqStack *s, ElemType *e)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (s-&gt;top == s-&gt;base)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  *e = *--(s-&gt;top);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>清空一个栈<br>将栈中的元素全部作废，但是栈本身物理空间并不发生改变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClearStack</span><span class="hljs-params">(sqStack *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  s-&gt;top = s-&gt;base;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>销毁一个栈<br>释放掉该栈所占据的物理内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyStack</span><span class="hljs-params">(sqStack *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, len;<br>  len = s-&gt;stackSize;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>  &#123;<br>    <span class="hljs-built_in">free</span>(s-&gt;base);<br>    s-&gt;base++;<br>  &#125;<br>  s-&gt;base = s-&gt;top = <span class="hljs-literal">NULL</span>;<br>  s-&gt;stackSize = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算栈的当前容量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackLen</span><span class="hljs-params">(sqStack s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> (s.top - s.base);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-3-用栈实现进制转换"><a href="#3-2-3-用栈实现进制转换" class="headerlink" title="3.2.3 用栈实现进制转换"></a>3.2.3 用栈实现进制转换</h3><ul><li><p>二进制转十进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ElemType c;<br>  sqStack s;<br>  <span class="hljs-keyword">int</span> len, i, sum = <span class="hljs-number">0</span>;<br><br>  InitStack(&amp;s);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入二进制数，输入#表示结束：&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c);<br><br>  <span class="hljs-keyword">while</span> (c != <span class="hljs-string">&#x27;#&#x27;</span>)<br>  &#123;<br>    Push(&amp;s, c);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c);<br>  &#125;<br><br>  getchar();<br><br>  len = StackLen(s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈的当前容量为：%d\n&quot;</span>, len);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>  &#123;<br>    Pop(&amp;s, &amp;c);<br>    sum = sum + (c - <span class="hljs-number">48</span>) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, i);<br>  &#125;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;十进制数为：%d\n&quot;</span>, sum);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二进制转八进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ElemType c;<br>  sqStack s;<br>  sqStack s2;<br>  <span class="hljs-keyword">int</span> len, len2, i, sum = <span class="hljs-number">0</span>;<br><br>  InitStack(&amp;s);<br>  InitStack(&amp;s2);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入二进制数，输入#表示结束：&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c);<br><br>  <span class="hljs-keyword">while</span> (c != <span class="hljs-string">&#x27;#&#x27;</span>)<br>  &#123;<br>    Push(&amp;s, c);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c);<br>  &#125;<br><br>  getchar();<br><br>  len = StackLen(s);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">3</span>)<br>  &#123;<br>    sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">3</span>; a++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (s.top != s.base)<br>      &#123;<br>        <span class="hljs-comment">/* code */</span><br>        Pop(&amp;s, &amp;c);<br>        <span class="hljs-keyword">int</span> f = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, a);<br>        sum = sum + (c - <span class="hljs-number">48</span>) * f;<br>      &#125;<br>    &#125;<br>    Push(&amp;s2, sum + <span class="hljs-number">48</span>);<br>  &#125;<br><br>  len2 = StackLen(s2);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n八进制数为：&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; len2; x++)<br>  &#123;<br>    Pop(&amp;s2, &amp;c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-3-栈的链式存储结构"><a href="#3-3-栈的链式存储结构" class="headerlink" title="3.3 栈的链式存储结构"></a>3.3 栈的链式存储结构</h2><ul><li>略</li></ul><h2 id="3-4-队列的定义"><a href="#3-4-队列的定义" class="headerlink" title="3.4 队列的定义"></a>3.4 队列的定义</h2><ul><li><p>队列(queue) 是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p></li><li><p>与栈相反，队列是一种先进先出(First In First Out , FIFO)的线性表。</p></li><li><p>队列既可以用链表实现，也可以用顺序表实现。</p></li><li><p>队列常用链表来实现，简称为链队列。</p></li></ul><h2 id="3-5-队列的链式存储结构"><a href="#3-5-队列的链式存储结构" class="headerlink" title="3.5 队列的链式存储结构"></a>3.5 队列的链式存储结构</h2><h3 id="3-5-1-链队列的定义"><a href="#3-5-1-链队列的定义" class="headerlink" title="3.5.1 链队列的定义"></a>3.5.1 链队列的定义</h3>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; QNode, *QueuePrt;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  QueuePrt front, rear;<br>&#125; LinkQueue;<br></code></pre></td></tr></table></figure><h3 id="3-5-2-链队列的基本操作"><a href="#3-5-2-链队列的基本操作" class="headerlink" title="3.5.2 链队列的基本操作"></a>3.5.2 链队列的基本操作</h3><ul><li><p>链队列的初始化</p><ol><li>在内存中创建一个头结点</li><li>将队列的头指针和尾指针都指向这个生成的头结点，因为此时是空队列。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(LinkQueue *q)</span></span><br><span class="hljs-function"></span>&#123;<br>  q-&gt;front = q-&gt;rear = (QueuePrt)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(QNode));<br>  <span class="hljs-keyword">if</span> (!q-&gt;front)<br>  &#123;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  q-&gt;front-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>链队列的入队列操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertQueue</span><span class="hljs-params">(LinkQueue *q, ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>  QueuePrt p;<br>  p = (QueuePrt)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(QNode));<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  p-&gt;data = e;<br>  p-&gt;next = <span class="hljs-literal">NULL</span>;<br>  q-&gt;rear-&gt;next = p;<br>  q-&gt;rear = p;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>链队列的出队列操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeleteQueue</span><span class="hljs-params">(LinkQueue *q, ElemType *e)</span></span><br><span class="hljs-function"></span>&#123;<br>  QueuePrt p;<br>  <span class="hljs-keyword">if</span> (q-&gt;front == q-&gt;rear)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  p = q-&gt;front-&gt;next;<br>  *e = p-&gt;data;<br>  q-&gt;front-&gt;next = p-&gt;next;<br>  <span class="hljs-keyword">if</span> (q-&gt;rear == p)<br>  &#123;<br>    q-&gt;rear = q-&gt;front;<br>  &#125;<br>  <span class="hljs-built_in">free</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>链队列的销毁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyQueue</span><span class="hljs-params">(LinkQueue *q)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span> (q-&gt;front)<br>  &#123;<br>    q-&gt;rear = q-&gt;front-&gt;next;<br>    <span class="hljs-built_in">free</span>(q-&gt;front);<br>    q-&gt;front = q-&gt;rear;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-6-队列的顺序存储结构"><a href="#3-6-队列的顺序存储结构" class="headerlink" title="3.6 队列的顺序存储结构"></a>3.6 队列的顺序存储结构</h2><h3 id="3-6-1-循环队列的定义"><a href="#3-6-1-循环队列的定义" class="headerlink" title="3.6.1  循环队列的定义"></a>3.6.1  循环队列的定义</h3><ul><li><p>循环队列的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType *base;<br><br>  <span class="hljs-keyword">int</span> front;<br>  <span class="hljs-keyword">int</span> rear;<br>&#125; cycleQueue;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-6-2-循环队列的基本操作"><a href="#3-6-2-循环队列的基本操作" class="headerlink" title="3.6.2 循环队列的基本操作"></a>3.6.2 循环队列的基本操作</h3><ul><li><p>循环队列的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(cycleQueue *q)</span></span><br><span class="hljs-function"></span>&#123;<br>  q-&gt;base = (ElemType *)<span class="hljs-built_in">malloc</span>(MAXSIZE * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElemType));<br>  <span class="hljs-keyword">if</span> (!q-&gt;base)<br>  &#123;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  q-&gt;front = q-&gt;rear = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>循环队列的入队列操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertQueue</span><span class="hljs-params">(cycleQueue *q, ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> ((q-&gt;rear + <span class="hljs-number">1</span>) % MAXSIZE == q-&gt;front)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  q-&gt;base[q-&gt;rear] = e;<br>  q-&gt;rear = (q-&gt;rear + <span class="hljs-number">1</span>) % MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>循环队列的出队列操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeleteQueue</span><span class="hljs-params">(cycleQueue *q, ElemType *e)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (q-&gt;front == q-&gt;rear)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  *e = q-&gt;base[q-&gt;front];<br>  q-&gt;front = (q-&gt;front + <span class="hljs-number">1</span>) % MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 笔记 - 2. 线性表</title>
    <link href="/2020/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---2.-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---2.-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h1><h2 id="2-1-线性表定义与特点"><a href="#2-1-线性表定义与特点" class="headerlink" title="2.1 线性表定义与特点"></a>2.1 线性表定义与特点</h2><span id="more"></span><p>线性表是<strong>零个或者多个数据元素的有限序列</strong>。</p><p>特性：</p><ul><li>数据元素之间是有序的</li><li>数据元素的个数是有限的</li><li>数据元素的类型必须相同</li></ul><h2 id="2-2-线性表的抽象数据类型定义"><a href="#2-2-线性表的抽象数据类型定义" class="headerlink" title="2.2 线性表的抽象数据类型定义"></a>2.2 线性表的抽象数据类型定义</h2><ul><li>ADT 线性表（List）</li><li>Data<ul><li>数据对象集合为{a1,a2,…,an}，每个元素的类型均为 DataType。</li><li>除了第一个元素外，每个元素有且只有一个直接前驱，除了最后一个元素外，每个元素有且只有一个直接后驱。</li><li>数据元素之间的关系是一对一的关系。</li></ul></li><li>Operation<ul><li><code>InitList(*L)</code>：初始化操作，建立一个空的线性表 L。</li><li><code>ListEmpty(L)</code>：判断是否为空表，若为空返回 true，否则返回 false。</li><li><code>ClearList(*L)</code>：将线性表清空。</li><li><code>GetElem(L,i,*e)</code>：将线性表 L 中的第 i 个位置元素值返回给 e。</li><li><code>LocateElem(L,e)</code>：在表 L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号，否则返回 0 表示失败。</li><li><code>ListInsert(*L,i,e)</code>：在表 L 中第 i 个位置插入新元素 e。</li><li><code>ListDelete(*L,i,*e)</code>：删除线性表 L 中第 i 个位置的元素，并用 e 返回其值。</li><li><code>ListLength(L)</code>：返回表 L 的元素个数。</li></ul></li><li>endADT</li></ul><h2 id="2-3-线性表的顺序存储结构"><a href="#2-3-线性表的顺序存储结构" class="headerlink" title="2.3 线性表的顺序存储结构"></a>2.3 线性表的顺序存储结构</h2><ul><li>定义<br>用一段地址连续的存储单元依次存储线性表的数据元素。</li></ul><p>线性表的元素个数 n（n&gt;=0）定义为线性表的长度，当 n=0 时，称为空表。</p><h3 id="2-3-1-顺序存储结构的封装"><a href="#2-3-1-顺序存储结构的封装" class="headerlink" title="2.3.1 顺序存储结构的封装"></a>2.3.1 顺序存储结构的封装</h3><ul><li>存储空间的起始位置，数组 data，它的存储位置就是线性表存储空间的存储位置</li><li>线性表的最大存储容量：数组的长度 MaxSize</li><li>线性表的当前长度：Length</li></ul><h3 id="2-3-2-地址计算方法"><a href="#2-3-2-地址计算方法" class="headerlink" title="2.3.2 地址计算方法"></a>2.3.2 地址计算方法</h3><p>对于第 i 个数据元素 ai 的存储位置可以由 a1 推算得出：</p><ul><li>LOC：获得存储位置的函数</li><li>c：每个 ElemType 占用的字节宽度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">LOC</span>(ai)=<span class="hljs-built_in">LOC</span>(a1)+(i<span class="hljs-number">-1</span>)*c<br></code></pre></td></tr></table></figure><h3 id="2-3-3-顺序表基本操作的实现"><a href="#2-3-3-顺序表基本操作的实现" class="headerlink" title="2.3.3 顺序表基本操作的实现"></a>2.3.3 顺序表基本操作的实现</h3><ul><li><p>初始化 <code>SqList.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TURE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType data[MAXSIZE];<br>  <span class="hljs-keyword">int</span> length;<br>&#125; SqList;<br></code></pre></td></tr></table></figure></li><li><p>GetElem</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;SqList.h&quot;</span></span><br><span class="hljs-comment">// 将线性表 L 中的第 i 个位置元素值返回给 e</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-keyword">int</span> i, ElemType *e)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; L.length || L.length == <span class="hljs-number">0</span> || i &lt; L.length)<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br>  *e = L.data[i - <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ListInsert</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;SqList.h&quot;</span></span><br><span class="hljs-comment">// 在表 L 中第 i 个位置插入新元素 e</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList *L, <span class="hljs-keyword">int</span> i, ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> k;<br><br>  <span class="hljs-keyword">if</span> (L-&gt;length == MAXSIZE)<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;length + <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br>  <span class="hljs-comment">// 插入位置后的元素依次向后顺延</span><br>  <span class="hljs-keyword">if</span> (i &lt;= L-&gt;length)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (k = L-&gt;length - <span class="hljs-number">1</span>; k &gt;= i - <span class="hljs-number">1</span>; k--)<br>    &#123;<br>      L-&gt;data[k + <span class="hljs-number">1</span>] = L-&gt;data[k];<br>    &#125;<br>  &#125;<br><br>  L-&gt;data[i - <span class="hljs-number">1</span>] = e;<br>  L-&gt;length++;<br><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ListDelete</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;SqList.h&quot;</span></span><br><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList *L, <span class="hljs-keyword">int</span> i, ElemType *e)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (L-&gt;length == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (i &gt; L-&gt;length || i &lt; <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br><br>  *e = L-&gt;data[i - <span class="hljs-number">1</span>];<br><br>  <span class="hljs-keyword">if</span> (i &lt; L-&gt;length)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &gt; L-&gt;length; k++)<br>    &#123;<br>      L-&gt;data[k - <span class="hljs-number">1</span>] = L-&gt;data[k];<br>    &#125;<br>  &#125;<br><br>  L-&gt;length--;<br><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-3-顺序存储结构的优缺点"><a href="#2-3-3-顺序存储结构的优缺点" class="headerlink" title="2.3.3 顺序存储结构的优缺点"></a>2.3.3 顺序存储结构的优缺点</h3><ul><li><p>优点</p><ul><li>无需为表示表中元素的逻辑关系而增加额外的存储空间</li><li>可以快速存取表中任意元素的数据</li></ul></li><li><p>缺点</p><ul><li>插入和删除需要移动大量的元素</li><li>当线性表的长度变化较大的时候，难以确定存储空间的容量</li><li>容易造成存储空间的”碎片“</li></ul></li></ul><h2 id="2-4-线性表的链式存储结构"><a href="#2-4-线性表的链式存储结构" class="headerlink" title="2.4 线性表的链式存储结构"></a>2.4 线性表的链式存储结构</h2><h3 id="2-4-1-定义与特点"><a href="#2-4-1-定义与特点" class="headerlink" title="2.4.1 定义与特点"></a>2.4.1 定义与特点</h3><ul><li><p>特点：</p><p>用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。</p></li><li><p>定义：</p><p>除了要存储数据元素信息外，还要存储它的后继元素的存储地址（指针）。存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域，这两部分信息组成数据元素称为存储映像，称为结点（Node）。<br>n 个结点链接成一个链表，即为线性表的链式存储结构。</p><p>因为此链表的每个结点指针域中只包含一个后继位置，所以叫做<strong>单链表</strong>。</p><p>链表中的第一个结点的存储位置叫做头指针，最后一个结点指针为空（NULL）。</p></li></ul><h3 id="2-4-2-头指针和头结点"><a href="#2-4-2-头指针和头结点" class="headerlink" title="2.4.2 头指针和头结点"></a>2.4.2 头指针和头结点</h3><p>首元结点：链表数据域中存放第一个数据元素的结点</p><ul><li><p>头指针</p><ul><li>头指针是指链表指向首元结点的指针，若链表有头结点，则是指向头结点的指针。</li><li>头指针具有标识作用，所以常用头指针冠以链表的名字（指针变量的名字）。</li><li>无论链表是否为空，头指针均不为空。</li><li>头指针是链表的必要元素。</li></ul></li><li><p>头结点</p><ul><li>为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度）。</li><li>有了头结点，对在首元结点前插入结点和删除首元结点等操作就与其他结点的操作形成统一。</li><li>头结点<strong>不一定</strong>是链表的必要元素。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">// 数据域</span><br>  ElemType data;<br>  <span class="hljs-comment">// 指针域</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">Next</span>;</span><br>&#125; Node;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-3-单链表基本操作的实现"><a href="#2-4-3-单链表基本操作的实现" class="headerlink" title="2.4.3 单链表基本操作的实现"></a>2.4.3 单链表基本操作的实现</h3><ul><li><p>初始化 <code>LinkList.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TURE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">// 数据域</span><br>  ElemType data;<br>  <span class="hljs-comment">// 指针域</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">Next</span>;</span><br>&#125; Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure></li><li><p>获取值 <code>GetElem</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LinkList.h&quot;</span></span><br><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-keyword">int</span> i, ElemType *e)</span></span><br><span class="hljs-function"></span>&#123;<br>  LinkList p;<br>  <span class="hljs-keyword">int</span> j;<br><br>  p = L-&gt;Next;<br>  j = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i)<br>  &#123;<br>    p = p-&gt;Next;<br>    ++j;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!p || j &gt; i)<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br><br>  *e = p-&gt;data;<br><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>插入值 <code>ListInsert</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LinkList.h&quot;</span></span><br><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> i, ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> j;<br>  LinkList p, q;<br>  p = *L;<br>  j = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i - <span class="hljs-number">1</span>)<br>  &#123;<br>    p = p-&gt;Next;<br>    j++;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!p || j &gt; i - <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br><br>  q = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node));<br><br>  q-&gt;Next = p-&gt;Next;<br>  p-&gt;Next = q;<br><br>  q-&gt;data = e;<br><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>删除值 <code>ListDelete</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LinkList.h&quot;</span></span><br><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> i, ElemType *e)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> j;<br>  LinkList p;<br><br>  p = *L;<br>  j = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i)<br>  &#123;<br>    p = p-&gt;Next;<br>    ++j;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!p || j &gt; i)<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br><br>  p-&gt;Next = p-&gt;Next-&gt;Next;<br><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-3-单链表的整表创建"><a href="#2-4-3-单链表的整表创建" class="headerlink" title="2.4.3 单链表的整表创建"></a>2.4.3 单链表的整表创建</h3><ul><li><p>创建单链表的过程是一个动态生成链表的过程，从”空表“的初始状态起，依次建立各元素节点并逐个插入链表。</p></li><li><p>算法思路</p><ul><li>声明一几点 p 和计数器变量 i</li><li>初始化一空链表 L</li><li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表</li><li>循环实现后继结点的赋值和插入</li></ul></li><li><p>头插法建立单链表</p><p>头插法从一个空表开始，生成新结点，读取数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头上，直到结束为止。</p><ol><li>先让新结点的 next 指向头结点之后</li><li>然后让表头的 next 指向新结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LinkList.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateListHead</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  LinkList p;<br>  <span class="hljs-keyword">int</span> i;<br><br>  <span class="hljs-built_in">arand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br><br>  *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node));<br>  (*L)-&gt;Next = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>  &#123;<br>    p = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node));<br>    p-&gt;data = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>    p-&gt;Next = (*L)-&gt;Next;<br>    (*L)-&gt;Next = p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>尾插法建立单链表</p><ul><li>先让尾部结点的 next 指向新结点</li><li>然后让新结点作为尾部结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LinkList.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateListTail</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  LinkList p, q;<br>  <span class="hljs-keyword">int</span> i;<br><br>  <span class="hljs-built_in">arand</span>(<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>));<br><br>  *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node));<br>  q = *L;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>  &#123;<br>    p = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node));<br>    p-&gt;data = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>    q-&gt;Next = p;<br>    q = p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-4-单链表的整表删除"><a href="#2-4-4-单链表的整表删除" class="headerlink" title="2.4.4 单链表的整表删除"></a>2.4.4 单链表的整表删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LinkList.h&quot;</span></span><br><br><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>  LinkList p, q;<br>  <span class="hljs-keyword">int</span> i;<br><br>  p = (*L)-&gt;Next;<br>  <span class="hljs-keyword">while</span> (p-&gt;Next)<br>  &#123;<br>    q = p-&gt;Next;<br>    <span class="hljs-built_in">free</span>(p);<br>    q = p;<br>  &#125;<br><br>  (*L)-&gt;Next = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-5-单链表结构与顺序存储结构的优缺点"><a href="#2-4-5-单链表结构与顺序存储结构的优缺点" class="headerlink" title="2.4.5 单链表结构与顺序存储结构的优缺点"></a>2.4.5 单链表结构与顺序存储结构的优缺点</h3><ul><li><p>存储分配方式</p><ul><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li></ul></li><li><p>时间性能</p><ul><li>查找<ul><li>顺序存储：O(1)</li><li>单链表：O(n)</li></ul></li><li>插入和删除<ul><li>顺序存储：需要平均移动表长一半的元素，时间为 O(n)</li><li>单链表：在计算出某位置的指针后，时间仅为 O(1)</li></ul></li></ul></li><li><p>空间性能</p><ul><li>顺序存储：需要预先分配存储空间，分大了，造成空间浪费，分小了，容易发生溢出</li><li>单链表：不需要分配存储空间，有就可以分配，元素个数不受限制</li></ul></li></ul><h3 id="2-4-6-循环链表"><a href="#2-4-6-循环链表" class="headerlink" title="2.4.6 循环链表"></a>2.4.6 循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。</p><ul><li>循环链表与单链表的区别 -&gt; 判断空链表<ul><li>单链表：<code>head-&gt;next == null</code></li><li>循环链表：<code>head-&gt;next == head</code></li></ul></li></ul><h3 id="2-4-7-双向链表"><a href="#2-4-7-双向链表" class="headerlink" title="2.4.7 双向链表"></a>2.4.7 双向链表</h3><ul><li><p>双向链表结点结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DualNode</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DualNode</span> *<span class="hljs-title">prior</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DualNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; DualNode, *DuLinkList;<br></code></pre></td></tr></table></figure></li><li><p>双向链表的基本操作</p><ul><li><p>插入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">s -&gt; next = p;<br>s -&gt; prior = p -&gt; prior;<br>p -&gt; prior -&gt; next = s;<br>p -&gt; prior = s;<br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">p -&gt; prior -&gt; next = p -&gt; next;<br>p -&gt; next -&gt; prior = p -&gt; prior;<br><span class="hljs-built_in">free</span>(p)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-4-8-双向循环链表的实践"><a href="#2-4-8-双向循环链表的实践" class="headerlink" title="2.4.8 双向循环链表的实践"></a>2.4.8 双向循环链表的实践</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;malloc/malloc.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DualNode</span></span><br><span class="hljs-class">&#123;</span><br>  ElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DualNode</span> *<span class="hljs-title">prior</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DualNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; DualNode, *DuLinkList;<br><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(DuLinkList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>  DualNode *p, *q;<br>  <span class="hljs-keyword">int</span> i;<br><br>  *L = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(DualNode));<br><br>  <span class="hljs-keyword">if</span> (!(*L))<br>  &#123;<br>    <span class="hljs-keyword">return</span> ERROR;<br>  &#125;<br><br>  (*L)-&gt;next = (*L)-&gt;prior = <span class="hljs-literal">NULL</span>;<br><br>  p = (*L);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>  &#123;<br>    q = (DualNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(DualNode));<br>    <span class="hljs-keyword">if</span> (!q)<br>    &#123;<br>      <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br><br>    q-&gt;data = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br><br>    q-&gt;prior = p;<br>    p-&gt;next = q;<br>    q-&gt;next = p-&gt;next;<br><br>    p = q;<br>  &#125;<br>  (*L)-&gt;next-&gt;prior = p;<br>  p-&gt;next = (*L)-&gt;next;<br>  (*L) = p;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Caesar</span><span class="hljs-params">(DuLinkList *L, <span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>      (*L) = (*L)-&gt;next;<br>    &#125; <span class="hljs-keyword">while</span> (--i);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>      (*L) = (*L)-&gt;prior;<br>    &#125; <span class="hljs-keyword">while</span> (++i);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  DuLinkList L;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">int</span> n = <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-built_in">InitList</span>(&amp;L);<br>  <span class="hljs-built_in">Caesar</span>(&amp;L, n);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>  &#123;<br>    L = L-&gt;next;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, L-&gt;data);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>完。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 笔记 - 1. 绪论</title>
    <link href="/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---1.-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0---1.-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基础概念及时间复杂度"><a href="#1-基础概念及时间复杂度" class="headerlink" title="1. 基础概念及时间复杂度"></a>1. 基础概念及时间复杂度</h1><h2 id="1-1-数据结构的基础概念"><a href="#1-1-数据结构的基础概念" class="headerlink" title="1.1 数据结构的基础概念"></a>1.1 数据结构的基础概念</h2><span id="more"></span><h3 id="数据结构（Data-Structure）"><a href="#数据结构（Data-Structure）" class="headerlink" title="数据结构（Data Structure）"></a>数据结构（Data Structure）</h3><ul><li>定义数据结构是指相互之间存在一种或多种特定关系的数据元素集合。<br>是计算机存储和组织数据的方式。</li></ul><p>数据结构研究非数值计算问题的程序中的操作对象和他们之间的关系，不是研究复杂的算法。</p><h2 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h2><h3 id="1-2-1-算法的概念"><a href="#1-2-1-算法的概念" class="headerlink" title="1.2.1 算法的概念"></a>1.2.1 算法的概念</h3><ul><li>定义算法是特定问题求解步骤的描述。</li></ul><p>对于算法而言，语言并不重要，重要的是思想。</p><h3 id="1-2-2-算法和数据结构的区别"><a href="#1-2-2-算法和数据结构的区别" class="headerlink" title="1.2.2 算法和数据结构的区别"></a>1.2.2 算法和数据结构的区别</h3><p>数据结构知识静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。</p><ul><li>算法是为了解决实际问题而设计的。</li><li>数据结构是算法需要处理的问题载体</li><li>数据结构与算法相辅相成</li></ul><h3 id="1-2-3-算法特性"><a href="#1-2-3-算法特性" class="headerlink" title="1.2.3 算法特性"></a>1.2.3 算法特性</h3><ul><li><strong>输入</strong>：算法具有 0 个或多个输入</li><li><strong>输出</strong>：算法至少有 1 个或多个输出</li><li><strong>有穷性</strong>：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在接受的时间内完成。</li><li><strong>确定性</strong>：算法中的每一步都有确定的含义，不会出现二义性。</li><li><strong>可行性</strong>：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成。</li></ul><h3 id="1-2-4-算法的效率统计"><a href="#1-2-4-算法的效率统计" class="headerlink" title="1.2.4 算法的效率统计"></a>1.2.4 算法的效率统计</h3><h4 id="1-2-4-1-事后统计法"><a href="#1-2-4-1-事后统计法" class="headerlink" title="1.2.4.1 事后统计法"></a>1.2.4.1 事后统计法</h4><ul><li><p>缺陷</p><ul><li>严重依赖硬件</li><li>需要对不同的算法编写相应的程序</li></ul></li><li><p>优势</p><ul><li>直观</li></ul></li></ul><h4 id="1-2-4-1-事前分析估算"><a href="#1-2-4-1-事前分析估算" class="headerlink" title="1.2.4.1 事前分析估算"></a>1.2.4.1 事前分析估算</h4><ul><li>只需要关注操作数量的最高次项，其他次要项和常数项可以忽略</li><li>算法的时间复杂度都是指最坏时间复杂度</li><li>只有常数项计做 1</li><li>操作数量的估算可以作为时间复杂度的估算</li></ul><h4 id="1-2-4-3-大-O-表示法"><a href="#1-2-4-3-大-O-表示法" class="headerlink" title="1.2.4.3 大 O 表示法"></a>1.2.4.3 大 O 表示法</h4><ul><li>只关注最高次项</li><li>时间复杂度是最坏时间复杂度</li><li>只有常数项计做 1</li><li>O(n)</li><li>O(1)</li><li>O(logN)</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 专升本 - 招生及考试信息汇总（计算机专业）</title>
    <link href="/2020/05/11/2020-%E4%B8%93%E5%8D%87%E6%9C%AC---%E6%8B%9B%E7%94%9F%E5%8F%8A%E8%80%83%E8%AF%95%E4%BF%A1%E6%81%AF%E6%B1%87%E6%80%BB%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%EF%BC%89/"/>
    <url>/2020/05/11/2020-%E4%B8%93%E5%8D%87%E6%9C%AC---%E6%8B%9B%E7%94%9F%E5%8F%8A%E8%80%83%E8%AF%95%E4%BF%A1%E6%81%AF%E6%B1%87%E6%80%BB%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年山东省专升本信息汇总（计算机专业）"><a href="#2020年山东省专升本信息汇总（计算机专业）" class="headerlink" title="2020年山东省专升本信息汇总（计算机专业）"></a>2020年山东省专升本信息汇总（计算机专业）</h1><blockquote><p>By n0T<br>Blog: n0T.top</p></blockquote><span id="more"></span><p><img src="http://cdn.n0t.top/img/%E5%B1%B1%E4%B8%9C%E4%B8%93%E5%8D%87%E6%9C%AC.png" alt="专升本流程图"></p><h2 id="2020年专升本招生计划表（疫情后扩招）"><a href="#2020年专升本招生计划表（疫情后扩招）" class="headerlink" title="2020年专升本招生计划表（疫情后扩招）"></a>2020年专升本招生计划表（疫情后扩招）</h2><blockquote><p>该人数适用于 高校推荐考生<br>自荐考生设立单独增列</p></blockquote><table><thead><tr><th align="center">本科专业</th><th align="center">招生学校</th><th align="center">原始人数</th><th align="center">扩招后</th></tr></thead><tbody><tr><td align="center">计算机科学与技术</td><td align="center">滨州学院</td><td align="center">40</td><td align="center">100</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">菏泽学院</td><td align="center">25</td><td align="center">100</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">济宁学院</td><td align="center">40</td><td align="center">100</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">聊城大学东昌学院</td><td align="center">50</td><td align="center">120</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">临沂大学</td><td align="center">60</td><td align="center">160</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">齐鲁理工学院</td><td align="center">65</td><td align="center">225</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">青岛科技大学（高密校区）</td><td align="center">65</td><td align="center">65</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">青岛理工大学（临沂校区）</td><td align="center">30</td><td align="center">80</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">青岛理工大学琴岛学院</td><td align="center">60</td><td align="center">100</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">青岛农业大学海都学院</td><td align="center">50</td><td align="center">125</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">山东财经大学燕山学院</td><td align="center">40</td><td align="center">105</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">山东第一医科大学</td><td align="center">40</td><td align="center">60</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">山东科技大学泰山科技学院</td><td align="center">90</td><td align="center">330</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">山东女子学院</td><td align="center">60</td><td align="center">120</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">山东青年政治学院</td><td align="center">70</td><td align="center">240</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">泰山学院</td><td align="center">50</td><td align="center">50</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">潍坊理工学院</td><td align="center">40</td><td align="center">340</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">烟台大学文经学院</td><td align="center">40</td><td align="center">60</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">中国石油大学胜利学院</td><td align="center">75</td><td align="center">90</td></tr><tr><td align="center">计算机科学与技术</td><td align="center">青岛工学院</td><td align="center">40</td><td align="center">240</td></tr><tr><td align="center">网络工程</td><td align="center">青岛滨海学院</td><td align="center">35</td><td align="center">150</td></tr><tr><td align="center">网络工程</td><td align="center">青岛恒星科技学院</td><td align="center">40</td><td align="center">160</td></tr><tr><td align="center">网络工程</td><td align="center">山东华宇工学院</td><td align="center">60</td><td align="center">160</td></tr><tr><td align="center">网络工程</td><td align="center">山东现代学院</td><td align="center">35</td><td align="center">100</td></tr><tr><td align="center">物联网工程</td><td align="center">青岛理工大学琴岛学院</td><td align="center">40</td><td align="center">40</td></tr><tr><td align="center">物联网工程</td><td align="center">山东农业工程学院</td><td align="center">60</td><td align="center">120</td></tr><tr><td align="center">物联网工程</td><td align="center">山东协和学院</td><td align="center">40</td><td align="center">80</td></tr></tbody></table><h2 id="2020年山东专升本统一考试-考试科目"><a href="#2020年山东专升本统一考试-考试科目" class="headerlink" title="2020年山东专升本统一考试 考试科目"></a>2020年山东专升本统一考试 考试科目</h2><table><thead><tr><th align="center">学科门类代码</th><th align="center">考试门类</th><th align="center">考试科目</th></tr></thead><tbody><tr><td align="center">08</td><td align="center">工学</td><td align="center">1. 英语 2. 计算机 3. 大学语文 4. 高等数学Ⅰ</td></tr></tbody></table><h2 id="各学校专业综合素质考试计划"><a href="#各学校专业综合素质考试计划" class="headerlink" title="各学校专业综合素质考试计划"></a>各学校专业综合素质考试计划</h2><blockquote><p>*：合格线为 同专业总成绩前10%的平均分的60%</p></blockquote><table><thead><tr><th align="center">招生学校</th><th align="center">考试科目1</th><th align="center">考试科目2</th><th align="center">招生人数/合格标准</th><th align="center">学费（年）</th></tr></thead><tbody><tr><td align="center">青岛科技大学高密校区</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">56人</td><td align="center">5000</td></tr><tr><td align="center">滨州学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">-</td><td align="center">8550+</td></tr><tr><td align="center">菏泽学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">*</td><td align="center">-</td></tr><tr><td align="center">济宁学院</td><td align="center">计算机操作系统</td><td align="center">数据结构</td><td align="center">*</td><td align="center">-</td></tr><tr><td align="center">聊城大学东昌学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">-</td><td align="center">16800</td></tr><tr><td align="center">临沂大学</td><td align="center">C语言程序设计；数据结构</td><td align="center">计算机网络基础</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">齐鲁理工学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">-</td><td align="center">19800</td></tr><tr><td align="center">青岛理工大学（临沂校区）</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">青岛理工大学琴岛学院</td><td align="center">C语言程序设计</td><td align="center">计算机网络基础</td><td align="center">70%/120分+/200分</td><td align="center">-</td></tr><tr><td align="center">青岛农业大学海都学院</td><td align="center">操作系统等相关知识</td><td align="center">-</td><td align="center">80分+/150分</td><td align="center">-</td></tr><tr><td align="center">山东财经大学燕山学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">-</td><td align="center">17000</td></tr><tr><td align="center">山东第一医科大学</td><td align="center">C语言程序设计</td><td align="center">操作系统</td><td align="center">60分+/100分</td><td align="center">-</td></tr><tr><td align="center">山东科技大学泰山科技学院</td><td align="center">C语言程序设计</td><td align="center">操作系统</td><td align="center">-</td><td align="center">17800</td></tr><tr><td align="center">山东青年政治学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">泰山学院</td><td align="center">操作系统</td><td align="center">数据结构</td><td align="center">60分+/100分</td><td align="center">-</td></tr><tr><td align="center">潍坊理工学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">100分+/200分</td><td align="center">15000</td></tr><tr><td align="center">烟台大学文经学院</td><td align="center">C语言程序设计</td><td align="center">操作系统</td><td align="center">60+</td><td align="center">-</td></tr><tr><td align="center">中国石油大学胜利学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">-</td><td align="center">12000</td></tr><tr><td align="center">青岛工学院</td><td align="center">C语言程序设计</td><td align="center">数据库概论</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">青岛滨海学院</td><td align="center">C语言程序设计</td><td align="center">计算机网络基础</td><td align="center">120分+/200分</td><td align="center">-</td></tr><tr><td align="center">青岛恒星科技学院</td><td align="center">操作系统</td><td align="center">计算机网络基础</td><td align="center">120分+/200分</td><td align="center">-</td></tr><tr><td align="center">山东现代学院</td><td align="center">C语言程序设计</td><td align="center">计算机网络基础</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">山东农业工程学院</td><td align="center">C语言程序设计</td><td align="center">计算机网络基础</td><td align="center">60分+/100分</td><td align="center">-</td></tr><tr><td align="center">山东协和学院</td><td align="center">C语言程序设计</td><td align="center">数据结构</td><td align="center">120分+/200分</td><td align="center">-</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>专升本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专升本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 专升本 - 山东省教育厅《政策解读》</title>
    <link href="/2020/05/11/2020-%E4%B8%93%E5%8D%87%E6%9C%AC---%E5%B1%B1%E4%B8%9C%E7%9C%81%E6%95%99%E8%82%B2%E5%8E%85%E3%80%8A%E6%94%BF%E7%AD%96%E8%A7%A3%E8%AF%BB%E3%80%8B/"/>
    <url>/2020/05/11/2020-%E4%B8%93%E5%8D%87%E6%9C%AC---%E5%B1%B1%E4%B8%9C%E7%9C%81%E6%95%99%E8%82%B2%E5%8E%85%E3%80%8A%E6%94%BF%E7%AD%96%E8%A7%A3%E8%AF%BB%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年普通专升本考试招生政策解读"><a href="#2020年普通专升本考试招生政策解读" class="headerlink" title="2020年普通专升本考试招生政策解读"></a>2020年普通专升本考试招生政策解读</h1><blockquote><p>By n0T<br>Blog: n0T.top<br>仅对原文无关内容删减，无改动。</p></blockquote><span id="more"></span><blockquote><p>原文发布日期：2020-01-11</p></blockquote><h2 id="一、2020年普通专升本考试招生政策出台的背景及意义"><a href="#一、2020年普通专升本考试招生政策出台的背景及意义" class="headerlink" title="一、2020年普通专升本考试招生政策出台的背景及意义"></a>一、2020年普通专升本考试招生政策出台的背景及意义</h2><p>  在学习借鉴其他省市成功做法和充分调研论证的基础上，2017年9月，山东省教育厅发布《关于调整普通高等教育专科升本科考试录取办法的通知》（鲁教学字〔2017〕21号），明确:</p><p>  自2020年起，取消专升本考试中的专业综合课考试科目，依据学生在校期间的综合素质测评成绩确定报考资格。</p><h2 id="二、2020年普通专升本招生对象有哪些？具体的报考条件是什么"><a href="#二、2020年普通专升本招生对象有哪些？具体的报考条件是什么" class="headerlink" title="二、2020年普通专升本招生对象有哪些？具体的报考条件是什么"></a>二、2020年普通专升本招生对象有哪些？具体的报考条件是什么</h2><p>  我省普通高等学校应届专科（高职）毕业生，分为“高校推荐考生”与“自荐考生”两类。</p><p>  应届专科毕业生可通过高校推荐或考生自荐的方式获得报考资格。</p><ol><li>高校推荐考生主要包括：<ol><li>在校期间的综合素质测评成绩排名不低于同年级、同专业前40%的学生；</li><li>参加省级以上职业院校技能大赛或省师范类高校学生从业技能大赛获三等奖以上的学生。</li></ol></li><li>自荐考生主要包括：<ol><li>未获得高校推荐资格的应届专科毕业生。该类考生须通过招生高校的专业综合能力测试后，获得报考该校的资格。</li></ol></li></ol><h2 id="三、为什么设立高校推荐考生和自荐考生两种报考资格"><a href="#三、为什么设立高校推荐考生和自荐考生两种报考资格" class="headerlink" title="三、为什么设立高校推荐考生和自荐考生两种报考资格"></a>三、为什么设立高校推荐考生和自荐考生两种报考资格</h2><p>  对综合素质测评成绩排名未进入同年级、同专业前40%的考生，通过增加专业综合能力测试的方式，可以有效检验考生能力。</p><p>  考生参加招生院校组织的专业综合能力测试合格后，可以获得报考资格，兼顾了这部分考生参加升学考试的需求。</p><p>  高校推荐考生和自荐考生有不同的升学通道，招生计划安排、考试录取等相对独立、互不影响。《通知》中公布的招生计划，只用于录取高校推荐考生。</p><p>  高校推荐考生投档录取结束后，自荐考生如果达到同学校同专业高校推荐考生的最低投档分数线，则以单独增加招生计划的方式录取。</p><h2 id="四、招生高校如何组织实施专业综合能力测试工作"><a href="#四、招生高校如何组织实施专业综合能力测试工作" class="headerlink" title="四、招生高校如何组织实施专业综合能力测试工作"></a>四、招生高校如何组织实施专业综合能力测试工作</h2><p>  招生高校于2020年1月17日前，通过本校官方网站公布分专业（类）测试方案。</p><p>  专业综合能力测试主要考察学生专业基础能力，包括两门专业考试科目，分为专业科目1和专业科目2，每个科目可覆盖1—2门专业基础课程，由招生高校根自主确定。</p><p>  招生高校专业综合能力测试时间全省统一确定为2020年2月17日—2月23日，具体测试时间由招生高校自行确定。</p><p>  自荐考生应于2020年2月8日前登录招生高校规定网站，按招生高校要求报名，并按时参加测试。</p><p>  同一个专业有多所高校招生的，自荐考生可以根据招生高校的测试时间安排，选择参加一所或多所学校的测试。</p><p>  专业综合能力测试标准由招生高校根据相关专业本科阶段学习需要确定，测试结果分为“合格”和“不合格”。</p><p>  自荐考生可以报考专业综合能力测试合格的招生高校和专业（类）。</p><h2 id="五、高校推荐考生、自荐考生以及退役士兵如何填报志愿"><a href="#五、高校推荐考生、自荐考生以及退役士兵如何填报志愿" class="headerlink" title="五、高校推荐考生、自荐考生以及退役士兵如何填报志愿"></a>五、高校推荐考生、自荐考生以及退役士兵如何填报志愿</h2><p>  专升本统一考试成绩公布后，由省教育招生考试院分专业划定填报志愿资格线。考生根据报名时选择的报考专业填报院校志愿和是否服从院校调剂志愿，院校志愿为平行志愿。</p><p>  高校推荐考生可以填报所报专业内的任何高校，最多填报25个院校平行志愿及“是否服从院校调剂”志愿。</p><p>  自荐考生只能填报所报专业内其<strong>获得自荐资格的高校</strong>。</p><h2 id="六、高校推荐考生、自荐考生以及退役士兵如何投档录取"><a href="#六、高校推荐考生、自荐考生以及退役士兵如何投档录取" class="headerlink" title="六、高校推荐考生、自荐考生以及退役士兵如何投档录取"></a>六、高校推荐考生、自荐考生以及退役士兵如何投档录取</h2><p>  高校推荐考生投档录取，依据考生4门公共基础课总成绩、所报志愿和分专业招生计划，按照平行志愿规则投档录取。</p><p>  自荐考生如果达到报考高校有关专业最低投档分数线，由省教育招生考试院依据考生4门公共基础课总成绩、所报志愿，按照平行志愿规则投档，所需招生计划单独增列，不占用高校推荐考生的招生计划。<br>  未达到报考高校有关专业投档分数线的自荐考生，不予投档录取。</p>]]></content>
    
    
    <categories>
      
      <category>专升本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专升本</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 山东专升本 - 山东省教育厅《通知》</title>
    <link href="/2020/05/11/2020-%E5%B1%B1%E4%B8%9C%E4%B8%93%E5%8D%87%E6%9C%AC---%E5%B1%B1%E4%B8%9C%E7%9C%81%E6%95%99%E8%82%B2%E5%8E%85%E3%80%8A%E9%80%9A%E7%9F%A5%E3%80%8B/"/>
    <url>/2020/05/11/2020-%E5%B1%B1%E4%B8%9C%E4%B8%93%E5%8D%87%E6%9C%AC---%E5%B1%B1%E4%B8%9C%E7%9C%81%E6%95%99%E8%82%B2%E5%8E%85%E3%80%8A%E9%80%9A%E7%9F%A5%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="关于做好2020年普通高等教育专科升本科考试招生工作的通知"><a href="#关于做好2020年普通高等教育专科升本科考试招生工作的通知" class="headerlink" title="关于做好2020年普通高等教育专科升本科考试招生工作的通知"></a>关于做好2020年普通高等教育专科升本科考试招生工作的通知</h1><blockquote><p>By n0T<br>Blog: n0T.top<br>仅对原文无关内容删减，无改动。</p></blockquote><span id="more"></span><blockquote><p>发布日期：2020-01-11<br>鲁教学字〔2020〕1号</p></blockquote><p>各市教育（教体）局，各高等学校：</p><p>根据《山东省教育厅关于调整普通高等教育专科升本科考试录取办法的通知》（鲁教学字〔2017〕21号），为做好2020年普通高等教育专科升本科（以下简称专升本）考试招生工作，现将有关事项通知如下。</p><h2 id="一、招生对象"><a href="#一、招生对象" class="headerlink" title="一、招生对象"></a>一、招生对象</h2><p>   我省2020年普通高等学校应届专科毕业生。</p><h2 id="二、报考条件"><a href="#二、报考条件" class="headerlink" title="二、报考条件"></a>二、报考条件</h2><p>   考生报考专升本需同时满足以下基本条件：</p><ul><li><p><strong>身体健康</strong>。</p></li><li><p>专科学习期间<strong>无记过及以上纪律处分</strong>，或专科学习期间受到记过或留校察看纪律处分，但报考前已解除处分的。</p></li><li><p>应届专科毕业生须通过<strong>毕业高校的综合素质测评</strong>获得<code>学校推荐资格</code>，或通过<strong>报考高校的专业综合能力测试</strong>获得<code>考生自荐资格</code>；</p></li></ul><h2 id="三、报考资格获得方式"><a href="#三、报考资格获得方式" class="headerlink" title="三、报考资格获得方式"></a>三、报考资格获得方式</h2><p>   应届专科毕业生可通过<strong>高校推荐或考生自荐</strong>的方式获得报考资格，并选择与本人<strong>专科所学专业相同或相近的专业</strong>（<strong>限一个</strong>）报考。</p><ol><li><p>高校推荐。<br>符合下列条件之一的学生，可获得高校推荐资格，经生源高校公示无异议后可以报考。</p><ol><li>在校期间的综合素质测评成绩排名不低于同年级、同专业的前40%。同专业使用不同人才培养方案的，可按培养方案分类排序。</li><li>参加省级以上职业院校技能大赛或省师范类高校学生从业技能大赛获三等奖以上的学生。由学生向生源高校提交申请和证明材料，生源高校负责审定。</li></ol></li></ol><p><strong>2. 考生自荐。</strong><br>   未获得高校推荐资格的学生，可以向意向报考专升本招生高校进行自荐，通过招生高校的<strong>专业综合能力测试</strong>后可以获得报考该校的资格。</p><h2 id="四、招生计划"><a href="#四、招生计划" class="headerlink" title="四、招生计划"></a>四、招生计划</h2><p>   2020年专升本招生院校、专业和招生人数根据招生院校办学基本情况及生源情况确定，具体见附件1，本计划专项用于录取高校推荐考生。</p><p>   对参加专升本统一考试，达到同学校同专业录取标准的自荐考生，<strong>单独增列招生计划</strong>。</p><h2 id="五、综合素质测评与专业综合能力测试"><a href="#五、综合素质测评与专业综合能力测试" class="headerlink" title="五、综合素质测评与专业综合能力测试"></a>五、综合素质测评与专业综合能力测试</h2><ol><li><p>综合素质测评。</p><p>综合素质测评成绩由课程学习成绩（学分绩点）和综合表现（包括思想品德状况、创新创业能力等）组成，其中课程学习成绩（学分绩点）所占比例不少于80%。</p></li><li><p><strong>专业综合能力测试。</strong></p><p>招生高校应于2020年1月17日前，通过本校官方网站公布分专业测试方案。</p><p>专业测试包括<strong>两门</strong>考试科目，每门考试科目应涵盖<strong>1—2门专业基础课程</strong>，由招生高校根据本校专业特点和人才培养要求<strong>自主确定</strong>。以笔试为主。允许招生高校根据人才选拔情况，在不同年度对考试科目所覆盖的课程及数量进行调整。</p><p>测试标准由招生高校根据相关专业本科阶段学习需要确定，测试结果分为“合格”和“不合格”。每所招生高校的专业综合能力测试结果，只能用于报考本校相关专业。</p><p>招生高校专业综合能力测试时间全省统一确定为2020年2月17日—2月23日，具体测试时间由招生高校自行确定。自荐考生应于2020年2月8日前登录招生高校规定网站，按招生高校要求报名，并按时参加测试。</p><p>同一个专业有多所高校招生的，自荐考生可以根据招生高校的测试时间安排，选择参加<strong>一所或多所</strong>学校的测试。</p></li></ol><h2 id="六、资格公示"><a href="#六、资格公示" class="headerlink" title="六、资格公示"></a>六、资格公示</h2><p>   通过高校推荐、考生自荐获得报考资格的考生名单，由生源高校、招生高校分别在学校网站进行公示，公示期不少于3个工作日。</p><p>   公示无异议后，生源高校、招生高校要分别将具有报考资格的考生名单报送省教育招生考试院，其中高校推荐考生名单由生源高校于2020年2月5日—2月8日报送，自荐考生名单由招生高校于2020年2月25日—2月28日报送。</p><p>   考生照片须为本人近期免冠正面头像照片，蓝色或红色背景，JPEG格式，高480像素X宽360像素左右，文件大小为30KB以内。</p><p>   生源高校、招生高校对其报送考生名单的真实性和完整性负责。</p><h2 id="七、统一考试报名"><a href="#七、统一考试报名" class="headerlink" title="七、统一考试报名"></a>七、统一考试报名</h2><p>   具有报考资格的考生（含高校推荐考生和自荐考生）<br>   于2020年3月4日至3月10日（工作日）<br>   登录<a href="http://zsb.sdzk.cn/">山东省普通高等教育专科升本科考试信息平台</a><br>   填报本人基本信息，同时选报一个与本人专科所学专业相同或相近的本科招生专业，并缴纳相关费用。</p><p>   选报专业一经确定，不得更改。</p><h2 id="八、统一考试安排"><a href="#八、统一考试安排" class="headerlink" title="八、统一考试安排"></a>八、统一考试安排</h2><p>   2020年普通专升本全省统一考试时间为3月21日、22日。</p><p>   考试科目为4门公共基础课，包括<strong>英语、计算机、大学语文、高等数学</strong>，每门科目考试时间<strong>120分钟</strong>、满分100分，总分满分400分。</p><p>   省教育招生考试院统一命题，统一考试，统一评卷。</p><p>   公共基础课依据《山东省2020年普通高等教育专科升本科招生考试公共基础课考试要求》组织命题。具体考试科目设置情况见附件2。</p><h2 id="九、志愿填报"><a href="#九、志愿填报" class="headerlink" title="九、志愿填报"></a>九、志愿填报</h2><p>   公共基础课成绩公布后，省教育招生考试院依据高校推荐考生的成绩和招生计划，<strong>分专业划定填报志愿资格线</strong>。</p><p>   达到填报志愿资格线的高校推荐考生和自荐考生，根据其在统一考试报名时选择的专业，登录<a href="http://zsb.sdzk.cn/">信息平台</a>填报志愿。</p><p>   高校推荐考生可以填报所报专业内的任何高校，最多填报25个院校平行志愿及“是否服从院校调剂”志愿；自荐考生只能填报所报专业内其获得自荐资格的高校。<br>   志愿填报日期及具体办法由省教育招生考试院另文公布。</p><h2 id="十、投档录取"><a href="#十、投档录取" class="headerlink" title="十、投档录取"></a>十、投档录取</h2><p>   为保证录取质量，设定总成绩最低录取分数线，且分专业录取人数不超过报考人数的50%。</p><p>   高校推荐考生由省教育招生考试院依据考生4门公共基础课总成绩、所报志愿和分专业招生计划，按照平行志愿规则投档录取。</p><p>   自荐考生如果达到报考高校有关专业投档分数线，由省教育招生考试院依据考生4门公共基础课总成绩、所报志愿，按照平行志愿规则投档，以增列计划方式录取。未达到报考高校有关专业投档分数线的自荐考生不予投档录取。</p><h2 id="十一、入学政策"><a href="#十一、入学政策" class="headerlink" title="十一、入学政策"></a>十一、入学政策</h2><p>   被录取的专升本学生，持录取通知书、准考证、普通专科毕业证等按规定时间到录取高校报到，办理入学手续。报到时不能提供普通专科毕业证书的，由录取高校取消其入学资格。录取高校应在学生报到后3个月内，按照有关规定对学生进行复查，复查合格者予以注册，取得学籍；复查不合格者，不予学籍注册。专升本学生的学费标准与普通本科相应专业学费标准相同。</p><p>   专升本学生的修业年限一般为2至4年。学生按教学计划修完规定课程且成绩合格，由学校颁发普通高等教育本科毕业证书。专升本学生毕业证书须标注“在本校专科起点××专业本科学习”，符合学士学位授予条件的授予相应学位。</p><h2 id="十二、组织实施"><a href="#十二、组织实施" class="headerlink" title="十二、组织实施"></a>十二、组织实施</h2><p>   <code>省教育厅</code>负责制定专升本招生政策，监督和指导专升本组织实施工作，审核高校专升本招生章程。</p><p>   <code>省教育招生考试院</code>负责制定专升本报名、考试、命题、评卷及录取等环节的具体实施办法并组织实施。</p><p>   <code>生源高校</code>负责本校考生的综合素质测评和报考资格审核等工作。</p><p>   <code>招生高校</code>负责公布对自荐考生专业综合能力测试方案，组织测试并确定合格名单。依据录取规则，参加本校考生的招生录取。根据《山东省教育厅关于做好2016年度普通高校招生章程制订和备案工作的通知》（鲁教学字〔2016〕4号）制订专升本招生章程，于2020年1月18日前报我厅学生处核定后向社会公布，作为专升本招生依据。</p><blockquote><p>山东省教育厅<br>2020年1月9日</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>专升本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专升本</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackMac for Clover</title>
    <link href="/2020/05/05/HackMac-for-Clover/"/>
    <url>/2020/05/05/HackMac-for-Clover/</url>
    
    <content type="html"><![CDATA[<h1 id="黑苹果-EFI-配置记录-for-Clover"><a href="#黑苹果-EFI-配置记录-for-Clover" class="headerlink" title="黑苹果 EFI 配置记录 for Clover"></a>黑苹果 EFI 配置记录 for Clover</h1><p><em><strong>注意：此文章已过时</strong></em></p><blockquote><p>注：300系主板可添加SSDT补丁开启原生NVRAM支持，本文章部分配置实为多余配置，请自行斟酌。<br>博主已迁移OpenCore，并实现99%完美EFI。</p></blockquote><hr><span id="more"></span><blockquote><p>By n0T</p><p>Blog：blog.n0T.top</p><p>感谢 各位黑果大佬 的无私分享</p><p>包括但不限于：</p><p><a href="http://bbs.pcbeta.com/forum-561-1.html">远景论坛</a>    <a href="https://blog.daliansky.net/">黑果小兵的部落阁</a>    <a href="https://blog.xjn819.com/">xjn819</a>    <a href="https://blog.csdn.net/LeoForBest">LeoForBest</a></p></blockquote><h2 id="EFI-分享"><a href="#EFI-分享" class="headerlink" title="EFI 分享"></a>EFI 分享</h2><blockquote><p><a href="https://github.com/n0TToday/HackMac-Clover">GitHub</a></p></blockquote><h2 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h2><table><thead><tr><th align="center">类型</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center">CPU</td><td align="center"><code>Intel i5-8400</code></td></tr><tr><td align="center">内存</td><td align="center"><code>金士顿 2400MHz 8GB</code> * 2</td></tr><tr><td align="center">主板</td><td align="center"><code>技嘉 B360m Gaming HD</code></td></tr><tr><td align="center">BIOS</td><td align="center"><code>F12</code></td></tr><tr><td align="center">声卡</td><td align="center"><code>ALC887</code></td></tr><tr><td align="center">网卡</td><td align="center"><code>Realtek 8118</code></td></tr><tr><td align="center">显卡</td><td align="center"><code>RX 580 8G 2304SP</code></td></tr><tr><td align="center">蓝牙+Wi-Fi</td><td align="center"><code>BCM94360CS2</code></td></tr><tr><td align="center">磁盘 1</td><td align="center">系统盘：<code>三星 970 EVO Plus 250GB</code></td></tr><tr><td align="center">磁盘 2</td><td align="center"><code>金士顿 250GB SATA SSD</code> * 2</td></tr><tr><td align="center">磁盘 3</td><td align="center"><code>西部数据 4TB 监控机械盘</code></td></tr></tbody></table><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><ul><li>解锁了BIOS的<code>CFG Lock</code>，更换 <code>AptioMemoryFix-64.efi</code> ，解决内存问题</li><li>定制 <code>USB端口</code> </li><li>定制 <code>AMD显卡接口</code></li><li>CPU 变频正常</li><li>蓝牙、Wi-Fi 免驱</li><li>声卡输入输出正常</li><li>隔空投送 正常</li><li>显卡免驱，支持双硬解</li><li>开启 HiDPI</li><li>休眠正常</li><li>……</li></ul><h2 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h2><ul><li><p><del>对 NTFS 的读写操作</del></p><ol><li><p>安装 <code>FUSE for Mac</code></p></li><li><p>使用 <code>brew</code> 安装 <code>ntfs-3g</code></p></li><li><p><strong>关闭 <code>SIP</code></strong></p></li><li><p><strong>挂载系统目录 <code>sudo mount -uw /</code></strong></p></li><li><p>替换系统 NTFS 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo mv /sbin/mount_ntfs /sbin/mount_ntfs.orig        <br>sudo ln -s /usr/local/sbin/mount_ntfs /sbin/mount_ntfs<br></code></pre></td></tr></table></figure></li><li><p>重新启动</p></li></ol></li><li><p>关机时 卡程序坞（macOS Bug）</p></li><li><p>……（遇到再说）</p></li></ul><h2 id="Clover-配置"><a href="#Clover-配置" class="headerlink" title="Clover 配置"></a>Clover 配置</h2><ul><li>引导参数<ul><li><code>-lilubetaall</code></li><li><code>debug=0x100</code></li><li><code>-disablegfxfirmware</code></li><li><code>-no_compat_check</code></li><li><code>slide=0</code></li></ul></li><li>ACPI<ul><li>DSDT<ul><li>H_EC to EC</li><li>HDAS to HDEF</li><li>HECI to IMEI</li><li>GFX0 to IGPU</li><li>EHC1 to EH01</li><li>EHC2 to EH02</li></ul></li><li>Fixes<ul><li>修复关机</li></ul></li></ul></li><li>设备设置<ul><li>AppleALC 注入 id <code>1</code></li></ul></li><li>引导界面<ul><li>隐藏<ul><li>Preboot</li><li>Recovery</li><li>Legacy</li></ul></li><li>主题<ul><li>Catalina</li></ul></li></ul></li><li>显卡设置<ul><li>FBname：<code>Guariba</code></li><li>注入 AMD</li></ul></li><li>内核补丁<ul><li>解除 USB 端口 15 限制</li></ul></li><li>机型<ul><li>MacPro 7,1（2019）</li></ul></li></ul><h2 id="UEFI-amp-Kexts"><a href="#UEFI-amp-Kexts" class="headerlink" title="UEFI&amp;Kexts"></a>UEFI&amp;Kexts</h2><h3 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h3><ul><li>ApfsDriverLoader.efi</li><li>AppleImageCodec.efi</li><li>AptioMemoryFix-64.efi</li><li>AudioDxe.efi</li><li>DataHubDxe.efi</li><li>EmuVariableUefi.efi</li><li>FSInject.efi</li><li>HFSPlus.efi</li><li>MemoryAllocation.efi</li><li>NvmExpressDxe.efi</li><li>PartitionDxe.efi</li><li>VirtualSmc.efi</li></ul><h3 id="Kexts"><a href="#Kexts" class="headerlink" title="Kexts"></a>Kexts</h3><ul><li><del>AHCI_3rdParty_SATA.kext</del></li><li><del>SMCLightSensor.kext</del></li><li><del>AHCI_3rdParty_eSATA.kext</del></li><li>SMCProcessor.kext</li><li>AppleALC.kext</li><li>SMCSuperIO.kext</li><li>GenericUSBXHCI.kext</li><li>USBPorts.kext</li><li><del>HoRNDIS.kext</del></li><li>VirtualSMC.kext</li><li>Lilu.kext</li><li><del>VoodooPS2Controller_v1.9.2.kext</del></li><li>NoTouchID.kext</li><li>WhateverGreen.kext</li><li>RealtekRTL8111.kext</li><li>XHCI-300-series-injector.kext</li><li><del>SMCBatteryManager.kext</del></li></ul><h2 id="系统截图"><a href="#系统截图" class="headerlink" title="系统截图"></a>系统截图</h2><p><img src="http://cdn.n0t.top/img/HackMacSnippets.png" alt="HackMac"></p>]]></content>
    
    
    <categories>
      
      <category>HackMac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackMac</tag>
      
      <tag>Clover</tag>
      
      <tag>Geek</tag>
      
      <tag>macOS</tag>
      
      <tag>黑苹果</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>沉默的螺旋（Spiral of Silence Theory）</title>
    <link href="/2020/05/04/%E6%B2%89%E9%BB%98%E7%9A%84%E8%9E%BA%E6%97%8B%EF%BC%88Spiral-of-Silence-Theory%EF%BC%89/"/>
    <url>/2020/05/04/%E6%B2%89%E9%BB%98%E7%9A%84%E8%9E%BA%E6%97%8B%EF%BC%88Spiral-of-Silence-Theory%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>By n0T</p><p>Blog: n0T.top</p></blockquote><p>前几天逛 V站 的时候有个帖子里提到了这个<code>沉默的螺旋</code>，于是百科了相关概念，觉得很有意思，记录一下。</p><span id="more"></span><blockquote><p>The <strong>spiral of silence theory</strong> is a <a href="https://en.wikipedia.org/wiki/Political_science">political science</a> and <a href="https://en.wikipedia.org/wiki/Mass_communication">mass communication</a> theory proposed by the <a href="https://en.wikipedia.org/wiki/Germany">German</a> <a href="https://en.wikipedia.org/wiki/Political_scientist">political scientist</a> <a href="https://en.wikipedia.org/wiki/Elisabeth_Noelle-Neumann">Elisabeth Noelle-Neumann</a>. It states that a social group or society might isolate or exclude members due to the members’ opinions. This stipulates that individuals have a fear of <a href="https://en.wikipedia.org/wiki/Solitude">isolation</a>. This fear of isolation consequently leads to remaining silent instead of voicing opinions. Media is an important factor that influences both the dominant idea and <a href="https://en.wikipedia.org/wiki/Social_perception">people’s perception</a> of what the dominant idea is. The assessment of one’s <a href="https://en.wikipedia.org/wiki/Social_environment">social environment</a> may not always correlate with reality.</p><p>—— WiKi</p></blockquote><h2 id="1-基本现象"><a href="#1-基本现象" class="headerlink" title="1. 基本现象"></a>1. 基本现象</h2><p>人们在表达自己想法和观点的时候。如果看到自己赞同的观点受到广泛欢迎，就会积极参与进来，这类观点就会越发大胆地发表和扩散；而发觉某一观点无人或很少有人理会（有时会有群起而攻之的遭遇），即使自己赞同它，也会保持沉默。</p><p>意见一方的沉默造成另一方意见的增势，如此循环往复，便形成一方的声音越来越强大，另一方越来越沉默下去的螺旋发展过程。</p><h2 id="2-前提假设"><a href="#2-前提假设" class="headerlink" title="2. 前提假设"></a>2. 前提假设</h2><ol><li>社会将用孤立的方式来威胁那些与大多数人不一致的人，对孤立的恐惧不可抗拒。</li><li>对孤立的恐惧导致个人在任何时候都会试图评估舆论气候。</li><li>公众的行为会受到民意评估的影响。</li></ol><h2 id="3-重要概念"><a href="#3-重要概念" class="headerlink" title="3. 重要概念"></a>3. 重要概念</h2><ul><li><h3 id="准统计官能（quasi-statistical-organ）"><a href="#准统计官能（quasi-statistical-organ）" class="headerlink" title="准统计官能（quasi-statistical organ）"></a>准统计官能（quasi-statistical organ）</h3><p>学者Noelle-Neumann在历次的选举研究中发现，人类有观察环境中意见分配状况的能力，称为“<code>准统计官能</code>”</p><p>当人长久处在媒体讯息之下，久而久之自然会具备一种准统计官能，也就是感知外在氛围的能力，能够察觉媒体所呈现的主流意见，并且这些意见会转化为个人对于社会主要价值的认知。不过前提是，阅听人必须处在长时间的媒体渗透，也就是媒体讯息的暴露下，且个体间缺乏有效沟通，才会影响到态度层次，进而改变行为。</p></li><li><h3 id="多数的无知（pluralistic-ignorance）"><a href="#多数的无知（pluralistic-ignorance）" class="headerlink" title="多数的无知（pluralistic ignorance）"></a>多数的无知（pluralistic ignorance）</h3><p>人们“把带有自己倾向的感知与媒体过滤过的感知混合为一个结论无形的整体感觉，他们觉得这个判断来自自己的思考和经验”。人们通常会高估自己估计意见的能力，这种对多数人意见的错误观察，就称为“多数的无知”。在沉默的螺旋中，多数的无知指的是，即使个人对于某种意见持不赞成的态度，如果大众传播对这种意见持赞成态度的话，个人会错误的以为这种赞成态度是大多数人的意见。</p></li><li><h3 id="中坚分子（hard-core）"><a href="#中坚分子（hard-core）" class="headerlink" title="中坚分子（hard core）"></a>中坚分子（hard core）</h3><p>“在沉默的螺旋旋转过程中无视孤立的威胁的人”，被称为中坚分子。他们是一群愿意为自己的公开言论付出代价的人，这些特立独行的人通常与主流意见有所冲突。Noelle-Neumann表示，当某个意见被多数人赞成，以至于成为常识的时候，中坚分子成为最愿意公开发表意见的人，可能会导致沉默的螺旋的倒转。</p></li></ul><h2 id="4-理论内涵"><a href="#4-理论内涵" class="headerlink" title="4. 理论内涵"></a>4. 理论内涵</h2><ul><li><p>从<strong>心理学</strong>的范畴来看，包括以下四点:</p><ol><li><p>引发人类社会行为的最强烈动力之一就是“不被孤立”。</p></li><li><p>人类有观察环境中意见分配状况的能力，称为“准统计官能”。</p></li><li><p>因为害怕孤立，当人发现自己的意见与环境中强势意见符合的话，就会有比较高的意愿公开表达自己的意见；反之，则低。</p></li><li><p>社会中强势意见愈来愈强，弱势意见愈来愈弱，这种动力运作的过程成一螺旋状。</p></li></ol></li><li><p>从<strong>大众传播学</strong>观点来看，包括以下四点:</p><ol><li><p>人们通常会以为大众传播媒介上呈现的意见就代表了多数人的想法。</p></li><li><p>媒介在报导议题时，对不同的论点会做不同的强调，使得自觉中在媒介中发现自己论点的人较易找到自己的位置，也较乐意在公开场合发现自己的论点。</p></li><li><p>大众媒体在上述过程所能产生的力量相当大，如果媒介内容的同质性大时，会造成强大的宣传效果。</p></li><li><p>传播者，在民意形成的过程中扮演了举足重轻的角色。</p></li></ol></li><li><p>从<strong>社会学</strong>的范畴来看，包括以下两点:</p><ol><li><p>民意控制的过程，逾矩的行为会受到处罚，恰如其分的行为会受到奖赏，这样才能使得社会达到整合的目的。</p></li><li><p>即使是政府也必须屈服于民意之下。</p></li></ol></li></ul><p>内容来源：<a href="https://en.wikipedia.org/wiki/Spiral_of_silence">维基百科</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>社会现象</tag>
      
      <tag>随笔</tag>
      
      <tag>沉默的螺旋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 前端 学习路线</title>
    <link href="/2020/05/04/2020-%E5%89%8D%E7%AB%AF-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2020/05/04/2020-%E5%89%8D%E7%AB%AF-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>By n0T<br>Blog: n0T.top</p></blockquote><span id="more"></span><p><img src="http://cdn.n0t.top/img/WebStudy.png" alt="2020 前端 学习路线"></p><h2 id="1-静态页面开发"><a href="#1-静态页面开发" class="headerlink" title="1. 静态页面开发"></a>1. 静态页面开发</h2><ul><li>Git 的基本操作 通过 GitHub 进行项目代码管理</li><li><strong>HTML 标签和 CSS 基础</strong><ul><li>HTML + CSS 基础</li><li>CSS 语法</li><li>常见布局</li></ul></li><li><strong>JavaScript 基础</strong><ul><li>JS 基础语法</li><li>常见算法的 JS 实现</li><li>DOM 基础操作</li><li>BOM 基础操作</li><li>jQuery</li></ul></li><li>Photoshop 基础</li><li>实践项目<ul><li>电商网站</li></ul></li></ul><h2 id="2-动态页面开发-前后端交互"><a href="#2-动态页面开发-前后端交互" class="headerlink" title="2. 动态页面开发 ( 前后端交互 )"></a>2. 动态页面开发 ( 前后端交互 )</h2><ul><li>HTML 5 + CSS 3</li><li><strong>JS 高级</strong><ul><li>面向对象</li><li>作用域</li><li>原型</li><li>闭包</li><li>this</li><li>同步异步<ul><li>原生 ajax</li><li>jQuery 的 Ajax</li></ul></li><li>正则表达式</li><li>…</li></ul></li><li><strong>EcmaScript 新语法</strong><ul><li>Promise</li><li>Async</li><li>…</li></ul></li><li>基础后端<ul><li>Node.js</li><li>Express</li><li>模板引擎</li><li>HTTP 协议</li></ul></li><li>前端可视化<ul><li>canvas</li><li>Echarts</li></ul></li><li><strong>响应式布局</strong><ul><li>UI 框架<ul><li>Bootstrap</li><li>…</li></ul></li></ul></li><li>移动端开发<ul><li>移动端开发适配</li><li>移动端 jQuery</li></ul></li><li>实践项目<ul><li>TODO List</li><li>豆瓣 电影</li></ul></li></ul><h2 id="3-组件化开发"><a href="#3-组件化开发" class="headerlink" title="3. 组件化开发"></a>3. 组件化开发</h2><ul><li><strong>组件化框架 Vue / React</strong></li><li>打包工具 Webpack</li><li>Element UI</li><li>CSS 预处理<ul><li>SASS</li></ul></li><li>自动化构建<ul><li>gulp</li></ul></li><li>TypeScript 语法</li></ul><h2 id="4-综合问题"><a href="#4-综合问题" class="headerlink" title="4. 综合问题"></a>4. 综合问题</h2><ul><li>HTTP</li><li>跨域</li><li>安全问题</li><li>浏览器渲染</li><li>页面性能优化</li><li>防抖动（Debouncing）和节流阀（Throtting）</li><li>lazyload</li><li>前端错误监控</li><li>虚拟DOM</li><li>异步和单线程</li></ul><h2 id="5-实战"><a href="#5-实战" class="headerlink" title="5. 实战"></a>5. 实战</h2><ul><li>整站开发</li><li>中后台开发</li><li>移动端开发</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 笔记 - 6.Callback Hell 和 Promise</title>
    <link href="/2020/05/02/Node.js-%E7%AC%94%E8%AE%B0---6.Callback-Hell-%E5%92%8C-Promise/"/>
    <url>/2020/05/02/Node.js-%E7%AC%94%E8%AE%B0---6.Callback-Hell-%E5%92%8C-Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-学习笔记"><a href="#Node-js-学习笔记" class="headerlink" title="Node.js 学习笔记"></a>Node.js 学习笔记</h1><blockquote><p>By n0T<br>Blog: n0T.top</p></blockquote><span id="more"></span><h2 id="6-Callback-Hell-和-Promise"><a href="#6-Callback-Hell-和-Promise" class="headerlink" title="6. Callback Hell 和 Promise"></a>6. Callback Hell 和 Promise</h2><h3 id="6-1-Callback-Hell"><a href="#6-1-Callback-Hell" class="headerlink" title="6.1 Callback Hell"></a>6.1 Callback Hell</h3><h4 id="6-1-1-什么是回调地狱"><a href="#6-1-1-什么是回调地狱" class="headerlink" title="6.1.1. 什么是回调地狱"></a>6.1.1. 什么是回调地狱</h4><p><img src="http://cdn.n0t.top/img/20200504155034.png" alt="Callback Hell"></p><p>如图所示，大量的回调函数顺序嵌套的或类似风格的 JavaScript 代码，被称之为 <code>Callback Hell</code> 回调地狱。</p><h4 id="6-1-2-回调地狱的缺点"><a href="#6-1-2-回调地狱的缺点" class="headerlink" title="6.1.2 回调地狱的缺点"></a>6.1.2 回调地狱的缺点</h4><ul><li>代码耦合，一旦修改，原地爆炸。</li><li>无法使用 Try/Catch，无法排错，也是原地爆炸。</li></ul><h4 id="6-1-3-解决方法"><a href="#6-1-3-解决方法" class="headerlink" title="6.1.3 解决方法"></a>6.1.3 解决方法</h4><ul><li>Promise</li><li>async/await</li><li>…</li></ul><h3 id="6-2-Promise"><a href="#6-2-Promise" class="headerlink" title="6.2 Promise"></a>6.2 Promise</h3><h4 id="6-2-1-简介"><a href="#6-2-1-简介" class="headerlink" title="6.2.1 简介"></a>6.2.1 简介</h4><p><code>Promise</code> 是一个对象，它代表了一个异步操作的最终完成或者失败。</p><p>不同于“老式”的传入回调，在使用 Promise 时，会有以下约定：</p><ul><li>在本轮 事件循环 运行完成之前，回调函数是不会被调用的。</li><li>即使异步操作已经完成（成功或失败），在这之后通过 then() 添加的回调函数也会被调用。</li><li>通过多次调用 then() 可以添加多个回调函数，它们会按照插入顺序执行。</li></ul><p>Promise 很棒的一点就是<strong>链式调用（chaining）</strong>。</p><h4 id="6-2-2-使用"><a href="#6-2-2-使用" class="headerlink" title="6.2.2 使用"></a>6.2.2 使用</h4><p>连续执行两个或者多个异步操作是一个常见的需求，在上一个操作执行成功之后，开始下一个的操作，并带着上一步操作所返回的结果。我们可以通过创造一个 <strong>Promise 链</strong>来实现这种需求。</p><p><code>then()</code>函数会返回一个和原来不同的<strong>新的Promise</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = doSomething()<br><span class="hljs-keyword">const</span> promise2 = promise.then(successCallback, failureCallback)<br></code></pre></td></tr></table></figure><p>基本上，每一个 Promise 都代表了链中另一个异步过程的完成。</p><p>在过去，要想做多重的异步操作，会导致经典的<strong>回调地狱</strong>，现在，我们可以把回调绑定到返回的 Promise 上，形成一个 Promise 链：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">doSomething().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> doSomethingElse(result)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newResult</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> doThirdThing(newResult)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">finalResult</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Got the final result: &#x27;</span> + finalResult)<br>&#125;)<br>.catch(failureCallback)<br><span class="hljs-comment">// catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。</span><br></code></pre></td></tr></table></figure><h4 id="6-2-3-Demo"><a href="#6-2-3-Demo" class="headerlink" title="6.2.3 Demo"></a>6.2.3 Demo</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pReadFile</span>(<span class="hljs-params">filePath</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    fs.readFile(filePath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        reject(err)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        resolve(data)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br><br>pReadFile(<span class="hljs-string">&#x27;./data/a.txt&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>    <span class="hljs-keyword">return</span> pReadFile(<span class="hljs-string">&#x27;./data/b.txt&#x27;</span>)<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>    <span class="hljs-keyword">return</span> pReadFile(<span class="hljs-string">&#x27;./data/c.txt&#x27;</span>)<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 笔记 - 5. 回调函数</title>
    <link href="/2020/05/01/Node.js-%E7%AC%94%E8%AE%B0---5.-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <url>/2020/05/01/Node.js-%E7%AC%94%E8%AE%B0---5.-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-学习笔记"><a href="#Node-js-学习笔记" class="headerlink" title="Node.js 学习笔记"></a>Node.js 学习笔记</h1><blockquote><p>By n0T<br>Blog: n0T.top</p></blockquote><h2 id="5-回调函数"><a href="#5-回调函数" class="headerlink" title="5. 回调函数"></a>5. 回调函数</h2><span id="more"></span><h3 id="5-1-上层定义-下层调用"><a href="#5-1-上层定义-下层调用" class="headerlink" title="5.1. 上层定义 下层调用"></a>5.1. 上层定义 下层调用</h3><ul><li><p>如何获取 <code>fn</code> 内部的 <code>data</code> ?</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如何获取 fn 内部的 data</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;hello&#x27;</span><br>  &#125;, <span class="hljs-number">1000</span>)<br>  <span class="hljs-built_in">console</span>.log(data)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果直接调用函数 <code>fn</code> , 会直接输出 <code>undefined</code></li><li>因为函数是异步的,执行时1秒钟后才会定义变量 <code>data</code></li><li>而程序会先跳过 <code>定时器</code> , 直接执行 <code>console.log</code></li><li>而如果加入回调函数 <code>callback</code> , 让定时器执行完成后调用回调函数,则解决了无法获取到 <code>data</code> 的问题</li></ul></li><li><p>增加回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;hello&#x27;</span><br>    callback(data)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 调用 fn</span><br>fn(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(data)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>此时的 <code>callback</code> 在调用 <code>fn</code> 时,被定义为了</li><li><code>function (data) &#123;console.log(data)&#125;</code></li><li>而根据 <code>fn</code> 定义, 在定时器结束后 就会调用此回调函数</li><li>从而输出 <code>data</code> 的值</li></ul></li></ul><h3 id="5-2-Demo"><a href="#5-2-Demo" class="headerlink" title="5.2. Demo"></a>5.2. Demo</h3><ul><li><p>接收参数 回调错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新学生信息</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">exports</span>.updateById = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">student, callback</span>) </span>&#123;<br>  fs.readFile(dbPath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-keyword">return</span> callback(err)<br>    &#125;<br>    <span class="hljs-keyword">var</span> students = <span class="hljs-built_in">JSON</span>.parse(data).students<br><br>    <span class="hljs-comment">// 把 id 统一转换为数字类型</span><br>    student.id = <span class="hljs-built_in">parseInt</span>(student.id)<br><br>    <span class="hljs-comment">// 你要修改谁，就需要把谁找出来</span><br>    <span class="hljs-comment">// EcmaScript 6 中的一个数组方法：find</span><br>    <span class="hljs-comment">// 需要接收一个函数作为参数</span><br>    <span class="hljs-comment">// 当某个遍历项符合 item.id === student.id 条件的时候，find 会终止遍历，同时返回符合条件的遍历项整体</span><br>    <span class="hljs-keyword">var</span> stu = students.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> item.id === student.id<br>    &#125;)<br><br>    <span class="hljs-comment">// 遍历拷贝对象</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> student) &#123;<br>      stu[key] = student[key]<br>    &#125;<br><br>    <span class="hljs-comment">// 把对象数据转换为字符串</span><br>    <span class="hljs-keyword">var</span> fileData = <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>      <span class="hljs-attr">students</span>: students<br>    &#125;)<br><br>    <span class="hljs-comment">// 把字符串保存到文件中</span><br>    fs.writeFile(dbPath, fileData, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-comment">// 回调错误对象</span><br>        <span class="hljs-keyword">return</span> callback(err)<br>      &#125;<br>      <span class="hljs-comment">// 成功就没错，所以错误对象是 null</span><br>      callback(<span class="hljs-literal">null</span>)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接收参数 回调( 错误,数据 )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据 id 获取学生信息对象</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Number&#125;</span>   </span>id       学生 id</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Function&#125;</span> </span>callback 回调函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">exports</span>.findById = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, callback</span>) </span>&#123;<br>  fs.readFile(dbPath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-keyword">return</span> callback(err)<br>    &#125;<br>    <span class="hljs-keyword">var</span> students = <span class="hljs-built_in">JSON</span>.parse(data).students<br>    <span class="hljs-keyword">var</span> ret = students.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> item.id === <span class="hljs-built_in">parseInt</span>(id)<br>    &#125;)<br>    callback(<span class="hljs-literal">null</span>, ret)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 笔记 - 4. Express</title>
    <link href="/2020/05/01/Node.js-%E7%AC%94%E8%AE%B0---4.-Express/"/>
    <url>/2020/05/01/Node.js-%E7%AC%94%E8%AE%B0---4.-Express/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-学习笔记"><a href="#Node-js-学习笔记" class="headerlink" title="Node.js 学习笔记"></a>Node.js 学习笔记</h1><blockquote><p>By n0T<br>Blog: n0T.top</p></blockquote><h2 id="4-Express"><a href="#4-Express" class="headerlink" title="4. Express"></a>4. Express</h2><span id="more"></span><h3 id="4-1-起步"><a href="#4-1-起步" class="headerlink" title="4.1. 起步"></a>4.1. 起步</h3><ul><li><p>安装<br><code>npm i -S express</code></p></li><li><p>Hello World</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span><br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.send(<span class="hljs-string">&#x27;Hello World!&#x27;</span>))<br>app.listen(port, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app  on http://127.0.0.1:3000`</span>))<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-第三方模块-in-Express"><a href="#4-2-第三方模块-in-Express" class="headerlink" title="4.2. 第三方模块 in Express"></a>4.2. 第三方模块 in Express</h3><ul><li><p>Art-templat</p><ul><li><p>安装<br><code>npm i -S art-template express-art-template</code></p></li><li><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.engine(<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>说明</p><ul><li>第一个参数，表示，当渲染以 <code>.html</code> 结尾的文件的时候，使用 <code>art-template</code> 模板引擎</li><li>虽然不需要加载 <code>art-template</code> 但是也必须安装<br>原因在于 <code>express-art-template</code> 依赖了 <code>art-template</code></li><li>Express 为 Response 相应对象提供了一个方法：<code>render</code></li><li><code>res.render(&#39;html模板名&#39;, &#123; 模板数据 &#125;)</code></li><li>第一个参数不能写路径，默认会去项目中的 <code>views</code> 目录查找该模板文件</li><li>也就是说 Express 有一个约定：开发人员把所有的视图文件都放到 views 目录中</li><li>如果想要修改默认的 <code>views</code> 目录，则可以</li><li><code>app.set(&#39;views&#39;, render函数的默认路径)</code></li></ul></li></ul></li><li><p>body-parser</p><ul><li><p>安装<br><code>npm i -S body-parser</code></p></li><li><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// parse application/x-www-form-urlencoded</span><br>app.use(bodyParser.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br><span class="hljs-comment">// parse application/json</span><br>app.use(bodyParser.json())<br></code></pre></td></tr></table></figure></li><li><p>说明</p><ul><li>专门用来解析表单 <code>POST</code> 请求体</li></ul></li></ul></li></ul><h3 id="4-3-处理静态资源"><a href="#4-3-处理静态资源" class="headerlink" title="4.3. 处理静态资源"></a>4.3. 处理静态资源</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">将 /public 指向本地路径 ./public<br>app.use(<span class="hljs-string">&#x27;/public&#x27;</span>,express.static(<span class="hljs-string">&#x27;./public&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="4-4-Router-路由挂载"><a href="#4-4-Router-路由挂载" class="headerlink" title="4.4. Router 路由挂载"></a>4.4. Router 路由挂载</h3><ul><li><p>router.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * router.js 路由模块</span><br><span class="hljs-comment"> * 职责：</span><br><span class="hljs-comment"> *   处理路由</span><br><span class="hljs-comment"> *   根据不同的请求方法+请求路径设置具体的请求处理函数</span><br><span class="hljs-comment"> * 模块职责要单一，不要乱写</span><br><span class="hljs-comment"> * 我们划分模块的目的就是为了增强项目代码的可维护性</span><br><span class="hljs-comment"> * 提升开发效率</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">var</span> Student = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./student&#x27;</span>)<br><br><span class="hljs-comment">// Express 提供了一种更好的方式</span><br><span class="hljs-comment">// 专门用来包装路由的</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-comment">// 1. 创建一个路由容器</span><br><span class="hljs-keyword">var</span> router = express.Router()<br><br><span class="hljs-comment">// 2. 把路由都挂载到 router 路由容器中</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 渲染添加学生页面</span><br><span class="hljs-comment">*/</span><br>router.get(<span class="hljs-string">&#x27;/students/new&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  res.render(<span class="hljs-string">&#x27;new.html&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * app.js 入门模块</span><br><span class="hljs-comment"> * 职责：</span><br><span class="hljs-comment"> *   创建服务</span><br><span class="hljs-comment"> *   做一些服务相关配置</span><br><span class="hljs-comment"> *     模板引擎</span><br><span class="hljs-comment"> *     body-parser 解析表单 post 请求体</span><br><span class="hljs-comment"> *     提供静态资源服务</span><br><span class="hljs-comment"> *   挂载路由</span><br><span class="hljs-comment"> *   监听端口启动服务</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)<br><br><span class="hljs-keyword">var</span> app = express()<br><br><span class="hljs-comment">// 把路由容器挂载到 app 服务中</span><br>app.use(router)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 笔记 - 3. 模块系统</title>
    <link href="/2020/04/29/Node.js-%E7%AC%94%E8%AE%B0---3.-%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/04/29/Node.js-%E7%AC%94%E8%AE%B0---3.-%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-学习笔记"><a href="#Node-js-学习笔记" class="headerlink" title="Node.js 学习笔记"></a>Node.js 学习笔记</h1><blockquote><p>By n0T<br>Blog: n0T.top</p></blockquote><h2 id="3-Node-中的模块系统"><a href="#3-Node-中的模块系统" class="headerlink" title="3. Node 中的模块系统"></a>3. Node 中的模块系统</h2><span id="more"></span><p>使用 Node 编写应用程序主要在使用:</p><ul><li>EcmaScript 语言<ul><li>没有DOM</li></ul></li><li>核心模块<ul><li>文件操作 fs</li><li>网络操作 http</li><li>路径操作 url</li><li>操作系统 os</li><li>…</li></ul></li><li>第三方模块<ul><li>art-template</li></ul></li><li>自己写的模块<ul><li>自己创建的</li></ul></li></ul><h3 id="3-1-什么是模块化"><a href="#3-1-什么是模块化" class="headerlink" title="3.1 什么是模块化"></a>3.1 什么是模块化</h3><ul><li>文件作用域</li><li>通信规则<ul><li>加载 require</li><li>导出</li></ul></li></ul><h3 id="3-2-CommonJS-模块规范"><a href="#3-2-CommonJS-模块规范" class="headerlink" title="3.2 CommonJS 模块规范"></a>3.2 CommonJS 模块规范</h3><p>在 Node 中的 JavaScript 有一个很重要的概念:模块系统</p><ul><li>模块作用域</li><li>使用 require 方法来加载模块</li><li>使用 exports 接口对象来导出模块中的成员</li></ul><h4 id="3-2-1-加载-require"><a href="#3-2-1-加载-require" class="headerlink" title="3.2.1 加载 require"></a>3.2.1 加载 <code>require</code></h4><ul><li><p>规则:</p><ul><li><p>优先从缓存中加载</p></li><li><p>判断模块标识</p></li><li><p>第三方模块</p><ul><li>第三方模块的标识就是第三方模块的名称（不可能有第三方模块和核心模块的名字一致）</li><li>使用方式：<code>var 名字 = require(&#39;npm install 包名&#39;)</code></li><li><code>node_modules</code></li><li><code>node_modules/express</code></li><li><code>node_modules/express/package.json</code></li><li><code>node_modules/express/package.json main</code></li><li>如果 package.json 或者 package.json main 不成立，则查找备选项：index.js</li><li>如果以上条件都不成立，则继续进入上一级目录中的 node_modules 按照上面的规则继续查找</li><li>如果直到当前文件模块所属磁盘根目录都找不到，最后报错：<code>can not find module xxx</code></li></ul></li><li><p>package.json 包描述文件</p><ul><li><code>dependencies</code> 属性，用来保存项目的第三方包依赖项信息</li><li>建议每个项目都要<strong>有且只有一个</strong> package.json (存放在项目的根目录)</li><li>可以通过 <code>npm init [--yes]</code> 来生成 package.json 文件</li><li>为了保存依赖项信息，每次安装第三方包的时候都要加<code>--save</code></li></ul></li><li><p>npm</p><ul><li>开发人员可以把写好的框架、库发布到 npm 上</li><li>使用者在使用的时候就可以很方便的通过 npm 来下载</li><li>npm 常用命令<ul><li>install</li><li>uninstall</li></ul></li></ul></li></ul></li><li><p>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 自定义变量名称 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;模块&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><p>两个作用:</p><ul><li>执行被加载模块中的代码</li><li>得到被加载模块中的 <code>exports</code> 导出接口对象</li></ul><h4 id="3-2-2-导出-exports"><a href="#3-2-2-导出-exports" class="headerlink" title="3.2.2 导出 exports"></a>3.2.2 导出 <code>exports</code></h4><ul><li><p>Node 中是模块作用域, 默认文件中的所有成员只在当前文件模块有效</p></li><li><p>对于希望可以被其他模块访问的成员, 将这些成员挂载到 <code>exports</code> 接口对象中</p><ul><li><p>导出多个成员(必须在对象中)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.a = foo<br><span class="hljs-built_in">exports</span>.b = add<br></code></pre></td></tr></table></figure></li><li><p>导出单个成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = foo<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x,y</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-2-3-原理解析"><a href="#3-2-3-原理解析" class="headerlink" title="3.2.3 原理解析"></a>3.2.3 原理解析</h4><ul><li><p>exports 是 <code>module.exports</code> 的一个引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.foo = <span class="hljs-string">&#x27;bar&#x27;</span><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-built_in">module</span>.exports.foo = <span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>引用模块最终返回的是 <code>module.exports</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 笔记 - 2. 起步</title>
    <link href="/2020/04/26/Node.js-%E7%AC%94%E8%AE%B0---2.-%E8%B5%B7%E6%AD%A5/"/>
    <url>/2020/04/26/Node.js-%E7%AC%94%E8%AE%B0---2.-%E8%B5%B7%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="2-起步"><a href="#2-起步" class="headerlink" title="2. 起步"></a>2. 起步</h2><h3 id="2-1-安装-Node-环境"><a href="#2-1-安装-Node-环境" class="headerlink" title="2.1. 安装 Node 环境"></a>2.1. 安装 Node 环境</h3><span id="more"></span><ul><li><p>通过安装包安装</p><ul><li><a href="https://nodejs.org/zh-cn/">Node.js 官网</a></li></ul></li><li><p>NVS 安装 ( Windows )</p><ol><li><p>以管理员身份打开 <code>powershell</code></p></li><li><p>使用以下命令安装 <code>Choco</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-ExecutionPolicy</span> RemoteSigned<br><span class="hljs-built_in">iwr</span> https://chocolatey.org/install.ps1 <span class="hljs-literal">-UseBasicParsing</span> | <span class="hljs-built_in">iex</span><br></code></pre></td></tr></table></figure></li><li><p>使用  <code>Choco install nvs</code>安装 <code>nvs</code></p></li><li><p>使用 <code>nvs install lts</code>安装  <code>Node.js LTS</code>版本</p></li><li><p>使用 <code>nvs link lts</code>设置系统环境变量</p></li></ol></li></ul><h3 id="2-2-Hello-World"><a href="#2-2-Hello-World" class="headerlink" title="2.2. Hello World"></a>2.2. Hello World</h3><ol><li><p>创建 JS 文件</p></li><li><p>开启命令行 使用 <code>node FileName.js</code> 执行</p><blockquote><p>禁止使用 node.js 命名；</p><p>最好不要使用 中文；</p></blockquote></li></ol><ul><li><p>解释执行 JavaScript</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ex = <span class="hljs-string">&#x27;Hello Node.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(ex)<br></code></pre></td></tr></table></figure></li><li><p>读写文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Node 中的 JavaScript 具有操作文件的能力</span><br><br><span class="hljs-comment">// fs 是 file-system 的简写</span><br><span class="hljs-comment">// fs 这个模块中提供了所有文件操作的API</span><br><br><span class="hljs-comment">// 1. 使用 require 方法 加载 fs 模块</span><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 2. 读取文件</span><br><span class="hljs-comment">// 第一个参数是 文件路径</span><br><span class="hljs-comment">// 第二个参数是 回调函数</span><br><span class="hljs-comment">//      成功</span><br><span class="hljs-comment">//          date：数据</span><br><span class="hljs-comment">//          err：null</span><br><span class="hljs-comment">//      失败</span><br><span class="hljs-comment">//          date：null</span><br><span class="hljs-comment">//          err：错误对象</span><br>fs.readFile(<span class="hljs-string">&#x27;./003.ex.txt&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err,data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;rereadFile:&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;读取失败&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(data.toString())<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 3. 写文件</span><br><span class="hljs-comment">// 第一个参数： 文件路径</span><br><span class="hljs-comment">// 第二个参数： 回调函数</span><br>fs.writeFile(<span class="hljs-string">&#x27;./003.ex.txt&#x27;</span>,<span class="hljs-string">&#x27;如果你能看到这段话 ， 就代表写入成功了&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;writeFile:&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;写入失败&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;写入成功&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>HTTP</p><ul><li><p>最简单的 Web Server :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 node 可以非常轻松的构建一个 web 服务器</span><br><span class="hljs-comment">// 提供了一个 核心模块: http</span><br><span class="hljs-comment">// 1. 加载http核心模块</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 2. 使用createServer创建一个server实例</span><br><span class="hljs-keyword">var</span> server = http.createServer()<br><br><span class="hljs-comment">// 3. 设置处理请求</span><br>server.on(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;收到请求&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 4. 绑定端口,启动服务器</span><br>server.listen(<span class="hljs-number">2333</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;服务器启动成功&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>访问不同 URL 来返回不同数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">server.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;收到请求,请求路径是:&#x27;</span> + request.url)<br><br>    <span class="hljs-comment">// res 的返回值只能是二进制数据或者字符串</span><br>    <span class="hljs-comment">// 如果不是的 需要转换</span><br>    <span class="hljs-comment">// JSON.stringify()</span><br><br>    <span class="hljs-keyword">if</span> (request.url === <span class="hljs-string">&#x27;/t&#x27;</span>) &#123;<br>        response.end(<span class="hljs-string">&#x27;This is a response&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        response.write(<span class="hljs-string">&#x27;Hello &#x27;</span>)<br>        response.end(<span class="hljs-string">&#x27;Node.js&#x27;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// response.write 可以执行多次,但必须用 response.end() 结束</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-3-Node-中的-JavaScript"><a href="#2-3-Node-中的-JavaScript" class="headerlink" title="2.3. Node 中的 JavaScript"></a>2.3. Node 中的 JavaScript</h3><ul><li><p>EcmaScript</p><ul><li>没有 DOM BOM</li></ul></li><li><p>核心模块</p><ul><li><p>Node 为 JavaScript 提供了很多服务器级 API , 都被包装到一个具名的核心模块中 .</p><p>例如 <code>fs</code> 文件操作模块 <code>http</code> 网络服务构建模块等</p></li><li><p>使用方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>用户模块</p><ul><li><p>在 Node 中 没有全局作用域 只有模块作用域<br>a.js 访问不到 b.js 内部的函数</p></li><li><p>require 调用模块时可以省略后缀名</p></li><li><p>相对路径中的 <code>./</code> 不能省略</p></li><li><p>导入模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 每个文件模块中都提供了一个对象</span><br><span class="hljs-comment">// exports</span><br><span class="hljs-comment">// 默认是一个空对象</span><br><br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(b)<br></code></pre></td></tr></table></figure></li><li><p>动态导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">z, c</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> z + c<br>&#125;<br><span class="hljs-comment">// 将需要外部访问的对象</span><br><span class="hljs-comment">// 动态加载到exports对象中</span><br><span class="hljs-built_in">exports</span>.foo = foo<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-4-Web-服务器开发"><a href="#2-4-Web-服务器开发" class="headerlink" title="2.4 Web 服务器开发"></a>2.4 Web 服务器开发</h3><ul><li><p>IP地址和端口号</p><ul><li>略</li></ul></li><li><p>设置字符编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br>http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>&#123;<br>    response.writeHead(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-comment">// Content-Type:设置客户端浏览器识别的文本类型</span><br>        <span class="hljs-comment">// plain: 普通文本</span><br>        <span class="hljs-comment">// HTML: HTML 代码</span><br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/HTML;charset=utf-8&#x27;</span><br>    &#125;);<br>    response.write(<span class="hljs-string">&#x27;&lt;p&gt;This is a HTML Type&lt;/p&gt;&#x27;</span>)<br>    response.end(<span class="hljs-string">&#x27;Hello World,中文&#x27;</span>);<br>&#125;).listen(<span class="hljs-number">8081</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server running at http://127.0.0.1:8081/&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>访问本地文件并以HTML形式传输</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">var</span> data = fs.readFileSync(<span class="hljs-string">&#x27;../../204.n0T.top/Dog/舔狗日记/index.html&#x27;</span>);<br><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br>http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>&#123;<br>    response.writeHead(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span><br>    &#125;);<br>    response.end(data.toString());<br>&#125;).listen(<span class="hljs-number">8081</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server running at http://127.0.0.1:8081/&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-5-使用服务端渲染界面"><a href="#2-5-使用服务端渲染界面" class="headerlink" title="2.5 使用服务端渲染界面"></a>2.5 使用服务端渲染界面</h3></li><li><p>Art-template</p><ul><li><p>each 是 art-template 的模板语法，专属的</p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;each 数组&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; $value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>&#123;&#123;/each&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>这是 art-template 模板引擎支持的语法，只能在模板字符串中使用</p></li><li><p>$.each(数组, function)</p></li><li><p>$(‘div’).each(function) 一般用于遍历 jQuery 选择器选择到的伪数组实例对象</p></li><li><p>forEach 是 EcmaScript 5 中的一个数组遍历函数，是 JavaScript 原生支持的遍历方法 可以遍历任何可以被遍历的成员</p></li><li><p>jQuery 的 each 方法和 forEach 几乎一致</p></li><li><p>由于 forEach 是 EcmaScript 5 中的，所以低版本浏览器不支持</p></li></ul></li><li><p>在 Node 中使用 art-template 模板引擎</p><ul><li>安装</li><li>加载</li><li>template.render()</li></ul></li><li><p>客户端渲染和服务端渲染的区别</p><ul><li>最少两次请求，发起 ajax 在客户端使用模板引擎渲染</li><li>客户端拿到的就是服务端已经渲染好的</li></ul></li><li><p>处理留言本案例首页数据列表渲染展示</p></li><li><p>处理留言本案例发表留言功能</p><ul><li>路径</li><li>设计好的请求路径</li><li>$GET 直接或查询字符串数据</li><li>Node 中需要解析<ul><li>url.parse()</li></ul></li><li>/pinglun?name=jack&amp;message=hello</li><li>split(‘?’)</li><li>name=jack&amp;message=hello</li><li>split(‘&amp;’)</li><li>name=jack message=hello</li><li>forEach()</li><li>name=jack.split(‘=’)</li><li>0 key</li><li>1 value</li></ul></li></ul><h3 id="2-6-其他"><a href="#2-6-其他" class="headerlink" title="2.6 其他"></a>2.6 其他</h3><ul><li>掌握如何解析请求路径中的查询字符串<ul><li>url.parse()</li></ul></li><li>如何在 Node 中实现服务器重定向<ul><li>header(‘location’)<ul><li>301 永久重定向 浏览器会记住<ul><li>a.com b.com</li><li>a 浏览器不会请求 a 了</li><li>直接去跳到 b 了</li></ul></li><li>302 临时重定向 浏览器不记忆<ul><li>a.com b.com</li><li>a.com 还会请求 a</li><li>a 告诉浏览器你往 b</li></ul></li></ul></li></ul></li><li>Node 中的 Console（REPL）使用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 笔记 - 1. 介绍</title>
    <link href="/2020/04/24/Node.js-%E7%AC%94%E8%AE%B0---1.-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/04/24/Node.js-%E7%AC%94%E8%AE%B0---1.-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>By n0T<br>Blog: n0T.top</p></blockquote><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><span id="more"></span><h3 id="1-1-Node-js-是什么"><a href="#1-1-Node-js-是什么" class="headerlink" title="1.1. Node.js 是什么"></a>1.1. Node.js 是什么</h3><ul><li>Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine.<ul><li>Node.js 不是一门语言</li><li>不是库、不是框架</li><li>是一个JavaScript运行时环境，可以解析执行JavaScript代码</li><li>Runtime 运行时</li><li>浏览器中的JavaScript<ul><li>EcmaScript<ul><li>var</li><li>function</li><li>Array</li><li>if</li><li>…</li></ul></li><li>DOM</li><li>BOM</li></ul></li><li>Node.js 中的JavaScript<ul><li><strong>没有BOM、DOM</strong></li><li>EcmaScript</li><li>服务端不处理DOM</li><li>提供了一些服务器级别的操作API<ul><li>文件操作</li><li>网络服务</li><li>数据传输</li><li>…</li></ul></li></ul></li></ul></li><li>Node.js uses an event-driven,non-blocking I/O model that makes it lightweight and efficient.<ul><li>event-driven 事件驱动</li><li>non-blocking I/O model 非阻塞IO模型（异步）</li><li>lightweight and efficient. 轻量和高效</li></ul></li><li>Node.js package ecosystem,npm,,is the largest ecosystem of open source libraries in the world.<ul><li>ecosystem 生态系统</li><li>npm 是世界上最大的开源库生态系统</li></ul></li></ul><h3 id="1-2-Node-js-能做什么"><a href="#1-2-Node-js-能做什么" class="headerlink" title="1.2. Node.js 能做什么"></a>1.2. Node.js 能做什么</h3><ul><li>Web 服务器后台</li><li>命令行工具<ul><li>npm(Node)</li><li>git(C)</li><li>hexo(Node)</li><li>brew</li><li>choco</li><li>…</li></ul></li></ul><h3 id="1-3-预备知识"><a href="#1-3-预备知识" class="headerlink" title="1.3. 预备知识"></a>1.3. 预备知识</h3><ul><li>HTML</li><li>css</li><li>JavaScript</li><li>简单的命令行操作</li><li>具有服务端开发经验</li></ul><h3 id="1-4-学习收获"><a href="#1-4-学习收获" class="headerlink" title="1.4. 学习收获"></a>1.4. 学习收获</h3><ul><li><p>B/S编程模型</p><ul><li>B: Browser</li><li>S: Server</li><li>任何服务端技术的 B/S 模型都是一样的，和语言无关</li><li>Node 只是作为我们学习 B/S 编程模型的一个工具</li></ul></li><li><p>模块化编程</p><ul><li>在Node中可以像<code>CSS</code>中的<code>@improt()</code>一样来引用加载JavaScript脚本文件</li></ul></li><li><p>Node 常用 API</p></li><li><p>异步编程</p><ul><li>回调函数</li><li>Promise</li><li>Async</li><li>generator</li></ul></li><li><p>Express 开发框架</p></li><li><p>Ecamscript 6</p></li><li><p>…</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell 出现 “在此系统上禁止运行脚本” 的解决</title>
    <link href="/2020/04/22/PowerShell-%E5%87%BA%E7%8E%B0-%E2%80%9C%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E2%80%9D-%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <url>/2020/04/22/PowerShell-%E5%87%BA%E7%8E%B0-%E2%80%9C%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E2%80%9D-%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="http://cdn.n0t.top/img/20200422110939.png" alt="错误提示"></p><blockquote><p>输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">get-executionpolicy</span><br></code></pre></td></tr></table></figure><p>显示 <strong>Restricted</strong> </p><p>即不允许执行任何脚本。</p></blockquote><p>故原因为 <strong>无权限执行脚本</strong></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>以管理员身份运行 PowerShell，并执行下列命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">set-executionpolicy</span> remotesigned<br></code></pre></td></tr></table></figure><p><img src="http://cdn.n0t.top/img/20200422111457.png"></p><p>再次执行命令即可成功。</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
      <tag>错误解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正当防卫4 Epic版设置中文</title>
    <link href="/2020/04/17/%E6%AD%A3%E5%BD%93%E9%98%B2%E5%8D%AB4-Epic%E7%89%88%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87/"/>
    <url>/2020/04/17/%E6%AD%A3%E5%BD%93%E9%98%B2%E5%8D%AB4-Epic%E7%89%88%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.n0t.top/img/jc4.jpg" alt="正当防卫4"></p><span id="more"></span><hr><h3 id="【正当防卫4】Epic版设置中文方法"><a href="#【正当防卫4】Epic版设置中文方法" class="headerlink" title="【正当防卫4】Epic版设置中文方法"></a>【正当防卫4】Epic版设置中文方法</h3><blockquote><p>正当防卫4 的游戏语言是会根据Epic平台的语言进行自动适配的，<br>而Epic平台默认的是根据系统的语言来自适应的中文。</p></blockquote><p>正当防卫4 应该是 <strong>没有适配好EPIC平台的中文</strong>，</p><p>我们可以通过切换中文后来使游戏匹配到正确的语言。</p><hr><p> 首先我们打开：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\用</span>户名<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\E</span>picGamesLauncher<span class="hljs-symbol">\S</span>aved<span class="hljs-symbol">\C</span>onfig<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\G</span>ameUserSettings.ini<br></code></pre></td></tr></table></figure><p> 然后再将文件的最后部分修改成以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Internationalization]</span><br><br><span class="hljs-attr">Culture</span>=zh-Hans<br></code></pre></td></tr></table></figure><p> 保存之后重启Epic平台运行正当防卫4。</p><hr><blockquote><p>如果我们设置成 <strong>zh-Hant</strong> 的话，</p><p>那么 Epic平台为繁体而游戏是简体；</p><p>如果设置成 <strong>zh-Hans</strong> 的话，</p><p>那么Epic平台是简体而游戏则成了繁体。</p></blockquote><hr><p><img src="http://cdn.n0t.top/img/JC4.png" alt="正当防卫4"></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正当防卫4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CSGO】上AK了！新阶段！</title>
    <link href="/2020/04/15/%E3%80%90CSGO%E3%80%91%E4%B8%8AAK%E4%BA%86%EF%BC%81%E6%96%B0%E9%98%B6%E6%AE%B5%EF%BC%81/"/>
    <url>/2020/04/15/%E3%80%90CSGO%E3%80%91%E4%B8%8AAK%E4%BA%86%EF%BC%81%E6%96%B0%E9%98%B6%E6%AE%B5%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h2 id="官匹终于上AK了！"><a href="#官匹终于上AK了！" class="headerlink" title="官匹终于上AK了！"></a>官匹终于上AK了！</h2><span id="more"></span><p>继上一个小目标（<em><strong>B5 1300分</strong></em>）达成后</p><p>今天把官匹打到了 <strong>AK</strong></p><p>发个帖纪念下</p><p><img src="http://cdn.n0t.top/img/AK.png" alt="AK！！！"></p><p><img src="http://cdn.n0t.top/img/fb8ab53bf552f82a7371be6ef48baaa.png" alt="30场数据"></p>]]></content>
    
    
    <categories>
      
      <category>CS:GO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSGO</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
